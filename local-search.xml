<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>tcp\/ip网络模型</title>
    <link href="/2020/08/19/tcp-ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/08/19/tcp-ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="tcp-ip-网络模型"><a href="#tcp-ip-网络模型" class="headerlink" title="tcp/ip 网络模型"></a>tcp/ip 网络模型</h2><p>分为五层，从上到下为应用层、传输层、网络层、数据链路层、物理层。</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h4 id="http（超文本传输协议）"><a href="#http（超文本传输协议）" class="headerlink" title="http（超文本传输协议）"></a>http（超文本传输协议）</h4><p>可以通过<code>curl url -v</code>查看一次完整的http请求过程</p><p><img src="/home/foon/.config/Typora/typora-user-images/image-20200919173124218.png" alt="image-20200919173124218"> </p><p>以上的流程可以总结为：</p><p>1、和服务器的端口建立tcp链接（默认为80端口）</p><p>2、发送http请求，包含请求头和请求体，请求头包含多个键值对<code>key1:value1</code>每行以<code>\r\n</code>分割，当遇到两个<code>\r\n</code>表示请求头的结束，接下来全是请求体</p><p>3、服务器返回响应，包含响应头和响应体，格式与http请求基本相同</p><p>4、和服务器断开tcp链接</p><h4 id="dns（域名系统）"><a href="#dns（域名系统）" class="headerlink" title="dns（域名系统）"></a>dns（域名系统）</h4><p>由于32位二进制的ip地址十分难记，我们使用域名来方便记忆。但是计算机不认识域名，前辈们就开发了dns域名系统，实现域名和ip的转换。</p><p>由于计算机无法理解dns系统之间的交流方式，所以通常通过一个resolver来和域名系统交流。我们将dns请求发给resolver,resolver来和dns交流，并返回给我们一个ip。查询域名为<a href="http://www.example.com的ip，完整的交流过程为：">www.example.com的ip，完整的交流过程为：</a></p><p>1、计算机将dns请求发给resolver</p><p>2、resolver询问根服务器，根服务器不知道，但是.com服务器知道。</p><p>3、于是resolver询问com服务器，com服务器表示exmaple.com知道</p><p>4、询问example.com,得到ip地址</p><p>当然，由于缓存的存在，通常我们不需要走完全程，例如resolver缓存了dns查询记录，我们直接就可以拿到结果。再比如我们缓存了com服务器知道结果，则直接询问com服务器。</p><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>使用公私钥加密方式，提供安全的隧道。</p><h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><h4 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h4><p>tcp报文记录了源端口和目的端口</p><p>端口一共有65535个，前1024个为公认端口，他们紧密绑定了一些服务。只有root有权限控制。</p><p>发送http请求时，源端口为系统任意选择大于1024的任意端口，目的端口默认为80</p><p>握手过程分为三步</p><p>1、客户端发送<code>SYN=x</code>，请求建立连接，客户端状态为syn-send</p><p>2、服务器收到，发送<code>SYN=y,ACK=x+1</code>,服务器状态为syn-received</p><p>3、客户端收到请求，发送<code>ACK=y+1</code>,连接建立</p><p>对于tcp的实现socket来说</p><p>服务端</p><p>1、使用socket创建监听套接字listenfd，调用bind绑定端口，调用listen监听端口,监听之后，套接字从CLOSED状态变为LISTEN状态</p><p>2、收到客户端发来的SYN报文，回复SYN+ACK,这时在未完成连接队列中创建一个新项目,并设置为SYN_RECV状态，然后继续监听listenfd</p><p>3、再次收到对应的ACK报文,把连接未完成队列中的项目移入连接已完成队列，并设置为ESTABLISHED状态</p><p>4、服务器通过accept进行消费，从已完成队列中拿取连接</p><p>netstat命令的Recv-Q和Send-Q表示的就是socket buffer相关的内容</p><p>对于监听状态的套接字，Recv-Q表示的是未完成队列中的连接个数，Send-Q表示的是未完成连接队列的最大连接限制个数</p><p>对于已经建立的tcp连接，Recv-Q列表示的是recv buffer中还未被用户进程拷贝走的数据大小，</p><p>Send-Q表示的是远程主机还未返回ACK消息的数据大小</p><p><img src="/home/foon/.config/Typora/typora-user-images/image-20200919185139646.png" alt="image-20200919185139646"> </p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><p>ipv4地址由32位二进制表示，也可以每八位一组来表示。</p><p>IP地址范围为0.0.0.0-255.255.255.255</p><p>其中10.0.0.0～10.255.255.255、172.16.0.0～172.16.255.255、192.168.0.0～192.168.255.255为内网地址，在公网上不分配，127开头的为环回地址，代表本机。</p><p>主机号全为0的表示直接广播地址，主机号全为1的表示受限广播地址，区别为广播是否会被发给路由器。</p><h4 id="icmp"><a href="#icmp" class="headerlink" title="icmp"></a>icmp</h4><p>icmp报文包含在ip报文中，头部的type说明icmp报文的作用</p><p>常见的type有</p><p>0：echo reply ping 应答</p><p>8：echo request ping请求</p><h4 id="ipsec"><a href="#ipsec" class="headerlink" title="ipsec"></a>ipsec</h4>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
