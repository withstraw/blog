<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>error学习道路上的坑</title>
    <link href="/2021/02/03/error%E5%AD%A6%E4%B9%A0%E9%81%93%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%9D%91/"/>
    <url>/2021/02/03/error%E5%AD%A6%E4%B9%A0%E9%81%93%E8%B7%AF%E4%B8%8A%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-error"><a href="#1-error" class="headerlink" title="#1 error"></a>#1 error</h1><p>符合error接口的即为error</p><pre><code class="hljs gauss"><span class="hljs-built_in">type</span> <span class="hljs-built_in">error</span> interface&#123;<span class="hljs-built_in">Error</span> <span class="hljs-built_in">func</span>()<span class="hljs-keyword">string</span>&#125;</code></pre><h1 id="2"><a href="#2" class="headerlink" title="#2"></a>#2</h1><p>go中最基本的error是一个包含了文本的结构体</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span>&#123;s <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-keyword">return</span> e.s</code></pre><p>他提供了一个api<code>New</code>以供创建error</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span>&#123;<span class="hljs-keyword">return</span> &amp;errorString&#123;s&#125;&#125;</code></pre><p>注意这里返回的是指针，错误的==比较即指针的比较。</p><p>而且每次创建都是不同的，即使字符串相同也是不同的。</p><h1 id="3-wrapError"><a href="#3-wrapError" class="headerlink" title="#3 wrapError"></a>#3 wrapError</h1><p>由于基本的error信息不够，很多情况下会wrap一下,官方最近也提供了相关的方法</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> wrapError <span class="hljs-keyword">struct</span>&#123;msg <span class="hljs-keyword">string</span>err error&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span><span class="hljs-title">Error</span><span class="hljs-params">()</span><span class="hljs-title">string</span></span>&#123;    <span class="hljs-keyword">return</span> e.msg&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span><span class="hljs-title">Unwrap</span><span class="hljs-params">()</span><span class="hljs-title">error</span></span>&#123;    <span class="hljs-keyword">return</span> e.err&#125;</code></pre><hr><p>方法fmt.Errorf包装</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span></code></pre><p>演示</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">var</span> err = errors.New(<span class="hljs-string">&quot;err&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Errorf(<span class="hljs-string">&quot;readfile %w&quot;</span>, err)<span class="hljs-comment">// &amp;fmt.wrapError&#123;msg:&quot;readfile err&quot;, err:(*errors.errorString)(0xc000010200)&#125;</span>fmt.Errorf(<span class="hljs-string">&quot;readfile %v&quot;</span>, err)<span class="hljs-comment">// &amp;errors.errorString&#123;s:&quot;readfile err&quot;&#125;</span>&#125;</code></pre><hr><p>方法errors.Unwrap解包</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unwrap</span><span class="hljs-params">(err error)</span><span class="hljs-title">error</span></span></code></pre><p>该方法调用wrapError的unWrap方法，如果没有定义unWrap方法，则返回nil</p><hr><p>方法errors.Is层层unwrap比较error,返回比较结果</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target error)</span><span class="hljs-title">bool</span></span></code></pre><hr><p>方法errors.As取回某一层中的error，返回是否存在该类型error</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">As</span><span class="hljs-params">(err error ,target <span class="hljs-keyword">interface</span>&#123;&#125;)</span><span class="hljs-title">bool</span></span></code></pre><p>值得注意的是Unwrap方法没有实现则一定返回false</p><p>值得注意的是target需要是一个指向error接口或者其他接口的指针</p><p>这里是还有个小坑，官方包除了提供一些已经初始化了的error值，还提供包装后的error类型，如</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span>&#123;Op,Path <span class="hljs-keyword">string</span>err error&#125;</code></pre><pre><code class="hljs go"><span class="hljs-keyword">var</span> err=&amp;os.PathError&#123;Op:<span class="hljs-string">&quot;a&quot;</span>,Path:<span class="hljs-string">&quot;&quot;</span>,Err:errors.New(<span class="hljs-string">&quot;c&quot;</span>)&#125;<span class="hljs-keyword">var</span> pe *os.PathErrore:=fmt.Errorf(<span class="hljs-string">&quot;abcd %w&quot;</span>,)errors.As(e,&amp;pe)</code></pre><p>如果这里不写&amp;pe的话，就会panic,说pe没有实现error接口。原因是T类型实现了func (T)foo()函数，<em>T类型实现了func (\</em>T)foo()、func (T)foo()函数。官方wrapError为我们实现的是接收指针的。这里官方解释说把一个指针赋给一个指针比把指针赋给一个值要好。</p><p>感觉挺复杂的，具体的error如io.EOF是一个指针<code>io.EOF-&gt;stringError&#123;&quot;EOF&quot;&#125;</code>,上文的e是一个指针<code>e-&gt;wrapError&#123;msg,err-&gt;stringError&#125;</code>。这样写下来好像还挺有道理的，感觉自己修行尚浅。</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>判断一个数是否是二的幂</title>
    <link href="/2021/02/01/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E7%9A%84%E5%B9%82/"/>
    <url>/2021/02/01/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E6%98%AF%E4%BA%8C%E7%9A%84%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="#1"></a>#1</h1><p>今天在学习go的库时，发现go的strconv库中的aoti.go文件中用到了一个函数,用来判断进制数base是否是2的幂次,2&lt;=base&lt;=40</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span><span class="hljs-title">bool</span></span>&#123;<span class="hljs-keyword">return</span> x&amp;(x<span class="hljs-number">-1</span>)==<span class="hljs-number">0</span>&#125;</code></pre><p>我自己的想法是二的幂次转换成二进制一定是0b10000……00,只有最高位是1.这样的数在-1后有另一个特征，所有位全部改变了,并且位数减少了1位,变为0b011111……11,两数相与为0.这里有一个特殊情况，即0.</p><h1 id="2"><a href="#2" class="headerlink" title="#2"></a>#2</h1><p>途中查找资料时发现了另一种相似方法</p><pre><code class="hljs go"><span class="hljs-keyword">return</span> (i&amp;-i)==i</code></pre><p>这个-i其实包含了反码等一系列操作，反码啥的其实记不太清了。</p><p>不过这让我想起了负数的补码表示方法中的验证部分，-i=0-i=0b10000-i具体细节见<a href=http://www.ruanyifeng.com/blog/2009/08/twos_complement.htm>关于2的补码</a></p><p>这也就可以跳跃到0b10000……00其实是一个0b10000……00进制的0,而-1后即变成了-1。似乎与模有些相关性，而且这个方法好像并不适用于非2的幂次的模，即不适用于判断如是否是3的幂次。这就与按位与运算扯上了关系。在此留下痕迹</p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 11个阶段</title>
    <link href="/2020/10/29/Nginx-11%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <url>/2020/10/29/Nginx-11%E4%B8%AA%E9%98%B6%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx-11个阶段"><a href="#Nginx-11个阶段" class="headerlink" title="Nginx 11个阶段"></a>Nginx 11个阶段</h1><h2 id="post-read阶段"><a href="#post-read阶段" class="headerlink" title="post_read阶段"></a>post_read阶段</h2><p>在nginx处理完请求首行url和请求头部header之后，对原始头部进行处理，例如realip模块在这个阶段获取可能经过代理的真实ip地址，通过X-Forwarded-For :ip1,ip2,ip3或X-Real-Ip:ip1头部来获取。</p><h2 id="server-rewrite阶段"><a href="#server-rewrite阶段" class="headerlink" title="server_rewrite阶段"></a>server_rewrite阶段</h2><p>匹配server,顺序为准确匹配-&gt;以*开头-&gt;以*结尾-&gt;依照顺序匹配正则表达式-&gt;最长的不完全匹配</p><p>通过server块中的配置进行rewrite</p><p>包括rewrite、return指令</p><h2 id="find-config阶段"><a href="#find-config阶段" class="headerlink" title="find_config阶段"></a>find_config阶段</h2><p>对location进行匹配</p><p>顺序为准确匹配-&gt;以*开头-&gt;以*结尾-&gt;依照顺序匹配正则表达式-&gt;最长的不完全匹配</p><h2 id="rewrite阶段"><a href="#rewrite阶段" class="headerlink" title="rewrite阶段"></a>rewrite阶段</h2><p>通过location中的配置进行rewrite</p><h2 id="preaccess阶段"><a href="#preaccess阶段" class="headerlink" title="preaccess阶段"></a>preaccess阶段</h2><p>三个access阶段都为访问管理阶段，pre_access限制ip。包括模块preaccess，会从connection、requests方面对ip进行限制。ngx_limit_req、nginx_limit_zone;</p><h2 id="access阶段"><a href="#access阶段" class="headerlink" title="access阶段"></a>access阶段</h2><p>用户验证相关、ngx_auth_request模块。access限制用户名密码包括deny、allow指令，对authorization的验证，通过对ip地址、uri等的hash进行验证。</p><h2 id="post-access阶段"><a href="#post-access阶段" class="headerlink" title="post_access阶段"></a>post_access阶段</h2><p>satisfy指令</p><h2 id="try-files阶段"><a href="#try-files阶段" class="headerlink" title="try_files阶段"></a>try_files阶段</h2><p>try_file指令，按顺序对指令后的uri进行尝试，@location进行内部跳转。</p><p>root,alias区别。一个是指定网站的根路径，一个是将uri映射为计算机上的路径，相当于一个别名。</p><p>root html;————————-&gt;location /a   /a/b/c ===========html/a/b/c      (alias / html)</p><p>alias html;————————-location /a /a/b/c============html/b/c</p><h2 id="content阶段"><a href="#content阶段" class="headerlink" title="content阶段"></a>content阶段</h2><p>可能对响应内容进行修改，例如gzip_fileter、image_fileter等模块。</p><h2 id="log阶段"><a href="#log阶段" class="headerlink" title="log阶段"></a>log阶段</h2><p>日志</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLS初窥</title>
    <link href="/2020/10/06/TLS%E5%88%9D%E7%AA%A5/"/>
    <url>/2020/10/06/TLS%E5%88%9D%E7%AA%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="TLS初窥"><a href="#TLS初窥" class="headerlink" title="TLS初窥"></a>TLS初窥</h2><h3 id="TLS位于哪一层"><a href="#TLS位于哪一层" class="headerlink" title="TLS位于哪一层"></a>TLS位于哪一层</h3><p>TLS建立于TCP之上，处于应用层和传输层之间。在OSI七层协议中，TLS握手协议属于会话层，TLS记录协议属于表示层。（但是有一种说法为TCP/ip五层协议其实是把OSI七层协议的上三层合为一个，也就是把应用层，表示层，会话层合为应用层，这么说的话是应用层也没错。）</p><p><img src="/home/foon/Blog/source/_posts/TLS%E5%88%9D%E7%AA%A5/SSL%E7%BB%93%E6%9E%84.png" alt="SSL结构"></p><h3 id="TLS握手协议"><a href="#TLS握手协议" class="headerlink" title="TLS握手协议"></a>TLS握手协议</h3><p><img src="/home/foon/Blog/source/_posts/TLS%E5%88%9D%E7%AA%A5/5bf4acc4377c4.png" alt="image"></p><ol><li>Client Hello:客户端发送自己的tls协议版本，一个随机数random_c,支持的加密套件（按优先级从高到低）</li><li>Server Hello:服务器端的tls协议版本，一个随机数random_s,选择的加密套件</li><li>Certificate:服务器端证书链（客户端验证证书链，取出公钥）</li><li>Server Hello Done: Hello阶段结束</li><li>Client Key Exchange: 客户端生成随机数pre master key,用服务器端公钥加密后发送，服务器和客户端用相同的算法，random_c,random_s,pre master key,生成用于对称加密的密钥</li><li>接下来的四步是一个单独的协议（Change Cipher Spec协议）</li></ol><h4 id="Change-Cipher-Spec协议"><a href="#Change-Cipher-Spec协议" class="headerlink" title="Change Cipher Spec协议"></a>Change Cipher Spec协议</h4><p><img src="/home/foon/Blog/source/_posts/TLS%E5%88%9D%E7%AA%A5/%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5.png" alt="第四阶段"></p><p>客户机启动SSL握手第4阶段，使服务器结束。该阶段分为4步，前2个消息来自客户机，后2个消息来自服务器。</p><p>建立起一个安全的连接，客户端发送一个Change Cipher Spec消息，并且把协商得到的CipherSuite拷贝到当前连接的状态之中。然后，客户端用新的算法、密钥参数发送一个Finished消息，这条消息可以检查密钥交换和认证过程是否已经成功。其中包括一个校验值，对客户端整个握手过程的消息进行校验。服务器同样发送Change Cipher Spec消息和Finished消息。握手过程完成，客户端和服务器可以交换应用层数据进行通信。</p><h5 id="ChangeCipherSpec"><a href="#ChangeCipherSpec" class="headerlink" title="ChangeCipherSpec"></a><strong>ChangeCipherSpec</strong></h5><p>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送（<strong>ChangeCipherSpec</strong>是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了）。</p><p><img src="/home/foon/Blog/source/_posts/TLS%E5%88%9D%E7%AA%A5/ClientChangeCipher.png" alt="ClientChangeCipher"></p><p>图：Cipher Spec Message报文</p><blockquote><p>是一条事件消息。</p></blockquote><h5 id="Clinet-Finished"><a href="#Clinet-Finished" class="headerlink" title="Clinet Finished:"></a><strong>Clinet Finished:</strong></h5><p><strong>客户端握手结束通知</strong>, 表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验（使用<strong>HMAC算法</strong>计算收到和发送的所有握手消息的摘要，然后通过RFC5246中定义的一个伪函数<a href="http://tools.ietf.org/html/rfc5246#section-5">PRF</a>计算出结果，加密后发送。此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。）</p><h5 id="Server-Finished"><a href="#Server-Finished" class="headerlink" title="Server Finished:"></a><strong>Server Finished:</strong></h5><p>服务端握手结束通知。</p><ol><li>使用私钥解密加密的Pre-master数据，基于之前(Client Hello 和 Server Hello)交换的两个明文随机数 random_C 和 random_S，计算得到协商密钥:enc_key=Fuc(random_C, random_S, Pre-Master);</li><li>计算之前所有接收信息的 hash 值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性;</li><li>发送一个 ChangeCipherSpec（告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了）</li><li>服务端也会使用 Session Secret 加密一段 Finish 消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。</li></ol><p>根据之前的握手信息，如果客户端和服务端都能对Finish信息进行正常加解密且消息正确的被验证，则说明握手通道已经建立成功，接下来，双方可以使用上面产生的Session Secret对数据进行加密传输了。</p><h3 id="TLS记录协议"><a href="#TLS记录协议" class="headerlink" title="TLS记录协议"></a>TLS记录协议</h3><h3 id="浏览器将TLS密钥存储为文件"><a href="#浏览器将TLS密钥存储为文件" class="headerlink" title="浏览器将TLS密钥存储为文件"></a>浏览器将TLS密钥存储为文件</h3><p>设置环境变量SSLKEYLOGFILE=/path/to/file,浏览器会将tls协议使用的密钥保存在该文件中。</p><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>TLS握手阶段协商了使用的加密套件，例如TLS_AES_128_GCM_SHA_256。</p><p>三个随机数random_c,random_s,pre master key用于生成对称加密密钥。该密钥用于后续数据传输。用三个随机数的原因是担心使用了伪随机算法，导致随机数可以被猜测。使用三个随机数，即使他们都是伪随机数，也很难被猜出。</p><p>服务端通过证书证明自己的身份，客户端用证书中的公钥来来加密数据。使用公私钥加密来传输对称加密密钥也是常见手段。</p><p>最后的Change Cipher Spec有点像tcp四次挥手，双方先后改变自己的状态（在这里切换到加密套件，tcp是改变通道的读写属性）</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcp四次挥手</title>
    <link href="/2020/10/02/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2020/10/02/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><h3 id="0x01过程"><a href="#0x01过程" class="headerlink" title="0x01过程"></a>0x01过程</h3><p>tcp连接是双工通道，双方都可以断开连接。假设链接双方为a,b</p><ol><li>a发送FIN=n报文，请求断开连接。进入FIN_WAIT1状态，发送FIN报文后不再发送任何数据，仅接受并确认报文</li><li>b收到FIN报文，回复ACK=n+1报文。b进入CLOSE_WAIT状态,a进入FIN_WAIT2状态</li><li>如果b有数据要发送，则继续发送。发送完成后发送FIN=m报文。b进入LAST_ACK状态，a进入TIME_WAIT状态</li><li>a回复ACK=m+1报文。如果a没有回复，b在超时后同样断开连接</li></ol><p>事实上，有些类似于a,b之间存在两条通道</p><p>一条是a&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;b,a发送，b接收</p><p>一条是a&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;b,a接受，b发送</p><p>每次FIN报文断开一条通道</p><h3 id="0x02抓包"><a href="#0x02抓包" class="headerlink" title="0x02抓包"></a>0x02抓包</h3><p><img src="image-20201002153438459.png" alt="image-20201002153438459"></p><p>但是，也存在一种可能性，如果被动关闭端b没有数据要发送，可以将第二次第三次挥手合并</p><pre><code class="hljs routeros">It is also possible <span class="hljs-keyword">to</span> terminate the<span class="hljs-built_in"> connection </span>by a 3-way handshake, when host A sends a FIN <span class="hljs-keyword">and</span> host B replies with a FIN &amp; ACK (merely combines 2 steps into one) <span class="hljs-keyword">and</span> host A replies with an ACK.</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket</title>
    <link href="/2020/10/02/WebSocket/"/>
    <url>/2020/10/02/WebSocket/</url>
    
    <content type="html"><![CDATA[<h2 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h2><h3 id="0x01-由来"><a href="#0x01-由来" class="headerlink" title="0x01 由来"></a>0x01 由来</h3><p>websocket协议是为了解决在http协议中使用双向传输的不便而提出的，例如游戏应用和即时信息就需要服务器向客户端发送数据。</p><p>使用http协议来进行双向传输导致的问题：</p><ul><li>服务器需要和每个不同的客户端建立很多tcp链接，向客户端传输数据需要一个链接，接受信息又需要一个</li><li>每个信息都需要http头部</li><li>客户端需要记录outgoing链接和incoming链接的对应关系</li></ul><p>解决这个问题的方法就是用一个tcp链接来进行双向传输，websocket正是这么做的。</p><p>websocket使用80（ws），445端口（wss）。websocket在握手阶段使用http协议，体现为提升协议。这样websocket可以支持已有的http代理和中间件。</p><h3 id="0x02-协议内容"><a href="#0x02-协议内容" class="headerlink" title="0x02 协议内容"></a>0x02 协议内容</h3><p>协议包含两部分:handshake（握手，挥手）和数据传输</p><h4 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h4><p>客户端的握手类似于</p><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> HTTP/1.1<span class="hljs-attribute">Host</span>: server.example.com<span class="hljs-attribute">Upgrade</span>: websocket<span class="hljs-attribute">Connection</span>: Upgrade<span class="hljs-attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==<span class="hljs-attribute">Origin</span>: http://example.com<span class="hljs-attribute">Sec-WebSocket-Protocol</span>: chat, superchat<span class="hljs-attribute">Sec-WebSocket-Version</span>: 13</code></pre><p>服务器端的握手类似于</p><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">101</span> Switching Protocols<span class="hljs-attribute">Upgrade</span>: websocket<span class="hljs-attribute">Connection</span>: Upgrade<span class="hljs-attribute">Sec-WebSocket-Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<span class="hljs-attribute">Sec-WebSocket-Protocol</span>: chat</code></pre><ul><li>Sec-WebSocket-Key、Sec-WebSocket-Accept字段用于认证身份，保证双方都经过了WebSocket握手阶段，而不是攻击者冒充</li><li>Upgrade和Connection字段，用于提升http协议为websocket协议</li><li>Sec-WebSocket-Protocol （可选字段）<ul><li>客户端，列出客户端允许哪些WebSocket子协议</li><li>服务器端，从客户端允许的列表中选择1或0个。</li></ul></li><li>Cookie、Sec-WebSocket-Extension等可选字段</li></ul><p>握手过程</p><ol><li><p>首先双方建立tcp链接</p></li><li><p>客户端发送握手报文，报文中带有Sec-WebSocket-Key</p></li><li><p>服务器端接受报文，将客户端发送的Sec-WebSocket-Key拼接上预定义的GUID（全局身份标识符），sha1加密为base64格式字符串，写入Sec-WebSocket-Accept字段，服务器端发送握手报文，状态码为101（任何非101状态码代表拒绝链接，如前文所说）</p></li><li><p>客户端接受报文，检查状态码是否为101,Sec-WebSocket-Accept字段是否正确，否则不建立链接</p></li></ol><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>成功握手后，服务器端和客户端就开始互相传输数据，在websocket协议中，数据又被叫做messages,一条message有一个或多个frames组成。websocket message可能会在网络层被分割为特殊的frame，之后再组合</p><p>一个frame会有一个type.相同message的每个frame的type是一样的。大致上，types区分了</p><p>文本数据（会被解析为utf-8文本）、二进制数据（交由应用解析）、控制信息（control frames 一般不携带数据，携带协议层的控制信号，例如关闭链接信号）。当前协议版本定义了六种frame types,保留10种</p><h4 id="挥手"><a href="#挥手" class="headerlink" title="挥手"></a>挥手</h4><ol><li>链接双方a,b中的一方a发送控制frame来关闭链接，发送控制frame后停止发送其他数据</li><li>另一方b收到，回复一个控制frame，</li><li>a收到，不再接受数据</li><li>当服务器收到关闭请求，立即tcp4次挥手。当客户端收到，等待服务器开始4次挥手</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内容安全策略CSP</title>
    <link href="/2020/09/29/%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5CSP/"/>
    <url>/2020/09/29/%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5CSP/</url>
    
    <content type="html"><![CDATA[<h2 id="内容安全策略CSP"><a href="#内容安全策略CSP" class="headerlink" title="内容安全策略CSP"></a>内容安全策略CSP</h2><h3 id="0x01同源策略"><a href="#0x01同源策略" class="headerlink" title="0x01同源策略"></a>0x01同源策略</h3><p>相同协议，相同域名，相同端口为同源（某些协议例外，如data协议）</p><p>http头部<code>Origin:源或空</code></p><pre><code class="hljs ini"><span class="hljs-attr">document.domain</span>=<span class="hljs-string">&quot;example.com&quot;</span>可以将源修改为当前域的父域，例www.exmaple.com-&gt;exmaple.com</code></pre><h3 id="0x02内容安全策略（content-security-proxy）"><a href="#0x02内容安全策略（content-security-proxy）" class="headerlink" title="0x02内容安全策略（content-security-proxy）"></a>0x02内容安全策略（content-security-proxy）</h3><p>可以写在http头部<code>Content-Security-Policy:default-src self;</code></p><p>可以写在html中head中<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;;&quot;</code></p><h3 id="0x03CSP做了什么"><a href="#0x03CSP做了什么" class="headerlink" title="0x03CSP做了什么"></a>0x03CSP做了什么</h3><p>CSP实质上是限制了html引用外部资源的源和外部资源的权限，来自某些origin的资源可以被执行，某些资源被当作静态资源</p><h3 id="0x04用法"><a href="#0x04用法" class="headerlink" title="0x04用法"></a>0x04用法</h3><p><code>Content-Security-Policy: policy</code></p><p>policy由一系列策略指令组成<code>Content-Security: default-src &lt;src&gt; &lt;src&gt;;script-src &lt;src&gt;</code></p><h4 id="lt-source-gt"><a href="#lt-source-gt" class="headerlink" title="&lt;source&gt;"></a>&lt;source&gt;</h4><p>&lt;source&gt;可以是</p><pre><code class="hljs vim"><span class="hljs-symbol">&lt;host-source&gt;</span>:scheme://hostname_or_ip:port 例如:http://*.example.<span class="hljs-keyword">com</span>、mail.example.<span class="hljs-keyword">com</span>:<span class="hljs-number">443</span>、http<span class="hljs-variable">s:</span>//store.example.<span class="hljs-keyword">com</span><span class="hljs-symbol">&lt;scheme-source&gt;</span>:schem<span class="hljs-variable">a:</span>//允许的协议名有http:、http<span class="hljs-variable">s:</span>、不推荐(dat<span class="hljs-variable">a:</span>、mediastream:、blo<span class="hljs-variable">b:</span>、filesystem:)<span class="hljs-string">&#x27;self&#x27;</span>:指向与要保护的文件所在的源<span class="hljs-string">&#x27;unsafe-inline&#x27;</span>:允许使用内联元素，如内联<span class="hljs-symbol">&lt;script&gt;</span>元素(javascrip<span class="hljs-variable">t:URL</span>)、内联事件处理器、内联<span class="hljs-symbol">&lt;style&gt;</span>元素<span class="hljs-string">&#x27;none&#x27;</span>:不允许任何内容<span class="hljs-string">&#x27;nonce-&lt;base64值&gt;&#x27;</span><span class="hljs-symbol">&lt;hash-source&gt;</span><span class="hljs-string">&#x27;strict-dynamic&#x27;</span>……</code></pre><h4 id="策略指令"><a href="#策略指令" class="headerlink" title="策略指令"></a>策略指令</h4><pre><code class="hljs groovy"><span class="hljs-keyword">default</span>-<span class="hljs-attr">src:</span>在资源不符合任何策略时的默认策略script-<span class="hljs-attr">src:</span> javascript资源，包含&lt;script&gt;元素、事件处理器(onclick)、可以引发脚本执行的XSLT stylesheets，还可以指定report-sample报告违反策略的样本child-<span class="hljs-attr">src:</span>&lt;frame&gt;&lt;iframe&gt;元素加载的资源（如果没有frame-src策略）form-<span class="hljs-attr">action:</span> 限制表单的提交地址connect-<span class="hljs-attr">src:</span>connect-src 指令用于控制允许通过脚本接口加载的链接地址。其中受到影响的API如下: &lt;a&gt; ping,Fetch,XMLHttpRequest,WebSocket, EventSource.font-<span class="hljs-attr">src:</span>字体frame-<span class="hljs-attr">src:</span>&lt;frame&gt;&lt;iframe&gt;元素加载的资源img-<span class="hljs-attr">src:</span>图片资源，包含img和faviconsmanifest-<span class="hljs-attr">src:</span>media-<span class="hljs-attr">src:</span>&lt;audio&gt;&lt;video&gt;元素加载的资源object-<span class="hljs-attr">src:</span>&lt;object&gt;&lt;embed&gt;&lt;applet&gt;style-<span class="hljs-attr">src:</span>css样式表worker-<span class="hljs-attr">src:</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL预编译</title>
    <link href="/2020/09/28/MySQL%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    <url>/2020/09/28/MySQL%E9%A2%84%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL预编译"><a href="#MySQL预编译" class="headerlink" title="MySQL预编译"></a>MySQL预编译</h2><h3 id="0x01使用方法"><a href="#0x01使用方法" class="headerlink" title="0x01使用方法"></a>0x01使用方法</h3><pre><code class="hljs mysql">prepare f from &#39;select * from user where id &#x3D; ?&#39;;set @id&#x3D;1;execute f using @id;</code></pre><p><code>prepare 名称 from &#39;sql语句&#39;</code>（使用占位符替代参数）</p><p>sql语句可以是通过任意方式构造的字符串类型变量或值</p><pre><code class="hljs mysql">DEALLOCATE PREPARE f;</code></pre><p>删除预编译语句,或者在mysql连接session关闭时自动删除</p><h3 id="0x02-能预编译的语句"><a href="#0x02-能预编译的语句" class="headerlink" title="0x02 能预编译的语句"></a>0x02 能预编译的语句</h3><pre><code class="hljs mysql">ALTER TABLEALTER USERANALYZE TABLECACHE INDEXCALLCHANGE MASTERCHECKSUM &#123;TABLE | TABLES&#125;COMMIT&#123;CREATE | DROP&#125; INDEX&#123;CREATE | RENAME | DROP&#125; DATABASE&#123;CREATE | DROP&#125; TABLE&#123;CREATE | RENAME | DROP&#125; USER&#123;CREATE | DROP&#125; VIEWDELETEDOFLUSH &#123;TABLE | TABLES | TABLES WITH READ LOCK | HOSTS | PRIVILEGES  | LOGS | STATUS | MASTER | SLAVE | USER_RESOURCES&#125;GRANTINSERTINSTALL PLUGINKILLLOAD INDEX INTO CACHEOPTIMIZE TABLERENAME TABLEREPAIR TABLEREPLACERESET &#123;MASTER | SLAVE&#125;REVOKESELECTSETSHOW &#123;WARNINGS | ERRORS&#125;SHOW BINLOG EVENTSSHOW CREATE &#123;PROCEDURE | FUNCTION | EVENT | TABLE | VIEW&#125;SHOW &#123;MASTER | BINARY&#125; LOGSSHOW &#123;MASTER | SLAVE&#125; STATUSSLAVE &#123;START | STOP&#125;TRUNCATE TABLEUNINSTALL PLUGINUPDATE</code></pre><h3 id="0x03防止sql注入的原理"><a href="#0x03防止sql注入的原理" class="headerlink" title="0x03防止sql注入的原理"></a>0x03防止sql注入的原理</h3><p>预编译一条sql语句，会将该sql语句编译后放到缓冲区中，待到execute执行语句时，将参数带入占位符再次进行解析，并执行。由于编译阶段已经识别了关键字，执行逻辑，输入的参数只能被作为字符串处理，无法做查询等操作了</p><h3 id="0x04-模拟预编译"><a href="#0x04-模拟预编译" class="headerlink" title="0x04 模拟预编译"></a>0x04 模拟预编译</h3><p>模拟预编译是为了防止某些版本的数据库不支持预编译，模拟预编译会在程序内部模拟数据库预处理的过程。也就是说，程序在内部模拟prepare,等到execute时，再将拼接后的完整sql语句发送给mysql数据库进行查询。</p><p>php模拟预编译本质上只是转义用户输入，相关函数是PDO::quote和mysqli_real_escape_string。</p><p>PDO可以通过PDO::ATTR_EMULATE_PREPARES参数控制是否开启模拟预编译，默认开启</p><h3 id="0x05预编译一定能防sql注入吗"><a href="#0x05预编译一定能防sql注入吗" class="headerlink" title="0x05预编译一定能防sql注入吗"></a>0x05预编译一定能防sql注入吗</h3><p>在prepare过程中的字符串拼接可能导致sql注入</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Requests库简单使用</title>
    <link href="/2020/09/21/Python-Requests%E5%BA%93%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/21/Python-Requests%E5%BA%93%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Python-Requests库简单使用"><a href="#Python-Requests库简单使用" class="headerlink" title="Python Requests库简单使用"></a>Python Requests库简单使用</h2><h3 id="0x1-requests-get"><a href="#0x1-requests-get" class="headerlink" title="0x1 requests.get"></a>0x1 requests.get</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsurl=<span class="hljs-string">&#x27;http://www.exmaple.com&#x27;</span>headers=&#123;    <span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;r=requests.get(url)<span class="hljs-comment">#自定义请求头</span>r=requests.get(url,headers=headers)r.status_code  <span class="hljs-comment">#状态吗</span>r.content   <span class="hljs-comment">#二进制字节码</span>r.text       <span class="hljs-comment">#文本格式响应</span></code></pre><h3 id="0x2-requests-post"><a href="#0x2-requests-post" class="headerlink" title="0x2 requests.post"></a>0x2 requests.post</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsdata=&#123;<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;cookies=&#123;<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;files=&#123;<span class="hljs-string">&quot;foo1&quot;</span>:<span class="hljs-string">&quot;filelikeobject&quot;</span><span class="hljs-string">&quot;foo2&quot;</span>:(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;/imge/png&quot;</span>)&#125;url=<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span><span class="hljs-comment">#上传数据</span>r=requests.post(url,data=<span class="hljs-string">&quot;l am in body&quot;</span>)<span class="hljs-comment">#上传表单数据</span>r=requests.post(url,data=data)<span class="hljs-comment">#上传文件</span>r=requests.post(url,files=files)<span class="hljs-comment">#带有cookies</span>r=requests.post(url,cookies=cookies)r.text</code></pre><h3 id="0x3-session"><a href="#0x3-session" class="headerlink" title="0x3 session"></a>0x3 session</h3><pre><code class="hljs routeros">import requests<span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;http://httpbin.org&quot;</span><span class="hljs-attribute">s</span>=requests.session()s.<span class="hljs-builtin-name">get</span>(url)s.post(url)</code></pre><pre><code class="hljs qml"><span class="hljs-keyword">import</span> requests<span class="hljs-built_in">url</span>=<span class="hljs-string">&quot;http://httpbin.org&quot;</span><span class="hljs-keyword">with</span> requests.Session() <span class="hljs-keyword">as</span> <span class="hljs-attribute">s</span>:s.get(<span class="hljs-built_in">url</span>)s.post(<span class="hljs-built_in">url</span>)</code></pre><p>0x4 proxy</p><pre><code class="hljs makefile">import requestsurl=<span class="hljs-string">&quot;http://httpbin.org&quot;</span>proxies=&#123;<span class="hljs-string">&quot;http&quot;</span>:<span class="hljs-string">&quot;127.0.0.1:7777&quot;</span>,<span class="hljs-string">&quot;https&quot;</span>:<span class="hljs-string">&quot;127.0.0.1:777&quot;</span>&#125;r=requests.get(url,proxies=proxies)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php 反序列化漏洞</title>
    <link href="/2020/08/22/php-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2020/08/22/php-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="php-反序列化漏洞"><a href="#php-反序列化漏洞" class="headerlink" title="php 反序列化漏洞"></a>php 反序列化漏洞</h2><h3 id="0x1整型的序列化"><a href="#0x1整型的序列化" class="headerlink" title="0x1整型的序列化"></a>0x1整型的序列化</h3><p><img src="image-20200921170331985.png" alt="image-20200921170331985"> </p><p>结果为<code>i:1;</code></p><p>i代表类型为整型，1为值</p><p>整型的序列化结果为<code>i:值;</code></p><h3 id="0x2字符串序列化"><a href="#0x2字符串序列化" class="headerlink" title="0x2字符串序列化"></a>0x2字符串序列化</h3><p><img src="image-20200921165623154.png" alt="image-20200921165623154"></p><p>结果为<code>s:6:&quot;string&quot;;</code> </p><p>s代表类型为字符串,6代表长度，string为值</p><p>字符串的序列化结果<code>s:长度:值;</code></p><h3 id="0x3-数组序列化"><a href="#0x3-数组序列化" class="headerlink" title="0x3 数组序列化"></a>0x3 数组序列化</h3><p><img src="image-20200921165824145.png" alt="image-20200921165824145"></p><p>结果为<code>a:1:&#123;s:3:&quot;foo&quot;;s:3:&quot;bar&quot;&#125;</code></p><p>a代表类型为数组，1代表数组长度，接着为值</p><p>s代表键的类型，3代表键的长度，接着为值</p><p>s代表值的类型，3代表值的长度，接着为值</p><p>数组的序列化结果<code>a:数组长度:&#123;键的序列化结果 值的序列化结果    键的序列化结果 值的序列化结果……&#125;</code></p><h3 id="0x4类的序列化结果"><a href="#0x4类的序列化结果" class="headerlink" title="0x4类的序列化结果"></a>0x4类的序列化结果</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span></span>&#123;    <span class="hljs-keyword">const</span> constant=<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">public</span> $bar1=<span class="hljs-number">1</span>;<span class="hljs-keyword">protected</span> $bar2=<span class="hljs-string">&#x27;2&#x27;</span>;<span class="hljs-keyword">private</span> $bar3=[<span class="hljs-string">&#x27;3&#x27;</span>];&#125;$f=<span class="hljs-keyword">new</span> foo();$s=serialize($f);<span class="hljs-keyword">echo</span> str_replace(chr(<span class="hljs-number">0</span>),<span class="hljs-string">&#x27;%00&#x27;</span>,$s).PHP_EOL;<span class="hljs-comment">#为了便于观看，将不可见的0x00变为%00</span></code></pre><p>结果为</p><pre><code class="hljs php">O:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;bar1&quot;</span>;i:<span class="hljs-number">1</span>;s:<span class="hljs-number">7</span>:<span class="hljs-string">&quot;%00*%00bar2&quot;</span>;s:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;2&quot;</span>;s:<span class="hljs-number">9</span>:<span class="hljs-string">&quot;%00foo%00bar3&quot;</span>;a:<span class="hljs-number">1</span>:&#123;i:<span class="hljs-number">0</span>;s:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;3&quot;</span>;&#125;&#125;</code></pre><p>O代表类型为对象，3为类的名称长度，foo为类的名称</p><p>接下来依次是类的成员变量名称与值的序列化结果，可以看到他们的名称发生了变化，这种变化与关键字protected,public,private有关</p><p>成员变量bar1为public,他的名称没有变化</p><p>成员变量bar2为protected,他的名称变为了<code>%00*%00bar2</code>,bar2为原来的名称</p><p>成员变量bar3为private,他的名称变为了<code>%00foo%00bar3</code>，foo为类名，bar3为原来的名称</p><p>对象的序列化结果<code>O:类名长度:类名:&#123;成员变量键序列化结果 成员变量值序列化结果 ……&#125;</code></p><p>其中成员变量键序列化结果有所不同 </p><p><code>protected 类型:键长度:%00*%00键名;</code></p><p><code>private 类型:键长度:%00类名%00键名;</code></p><h3 id="0x5-与反序列化有关的魔术方法-wakeup-sleep"><a href="#0x5-与反序列化有关的魔术方法-wakeup-sleep" class="headerlink" title="0x5 与反序列化有关的魔术方法 __wakeup,__sleep"></a>0x5 与反序列化有关的魔术方法 <code>__wakeup,__sleep</code></h3><p><code>__sleep</code>在对象被序列化时调用，返回包含对象中所有应被序列化的变量名称的数组（按照规定）</p><p><code>__wakeup</code>在对象被反序列化时调用，通常进行初始化操作，如果序列化字符串的个数出错，则不会调用。可以用于绕过<code>__wakeup</code>函数中的检查。</p><h3 id="0x6-一些可以利用的魔术方法-toString-invoke-callable-get-set-call"><a href="#0x6-一些可以利用的魔术方法-toString-invoke-callable-get-set-call" class="headerlink" title="0x6 一些可以利用的魔术方法 __toString,__invoke,__callable,__get,__set,__call"></a>0x6 一些可以利用的魔术方法 <code>__toString,__invoke,__callable,__get,__set,__call</code></h3><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString"></a>__toString</h4><p>当一个类被当作字符串时，会调用该方法。此方法必须返回一个字符串。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span></span>&#123;<span class="hljs-keyword">public</span> $bar1=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;&#125;&#125;$f=<span class="hljs-keyword">new</span> foo();<span class="hljs-keyword">echo</span> $f.PHP_EOL;</code></pre><p><img src="image-20200921173027418.png" alt="image-20200921173027418"></p><h4 id="invoke"><a href="#invoke" class="headerlink" title="__invoke"></a>__invoke</h4><p>当尝试以调用一个函数的方式调用一个对象，会调用该方法</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span></span>&#123;<span class="hljs-keyword">public</span> $bar1=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params">$x</span>)</span>&#123;var_dump($x);&#125;&#125;$f=<span class="hljs-keyword">new</span> foo();$f(<span class="hljs-number">10</span>);var_dump(is_callable($f));</code></pre><p>输出</p><p><img src="image-20200921173333544.png" alt="image-20200921173333544"></p><h4 id="get"><a href="#get" class="headerlink" title="__get"></a>__get</h4><p>在访问不可访问属性赋值时，如不存在的属性，会被调用。</p><h4 id="set"><a href="#set" class="headerlink" title="__set"></a>__set</h4><p>在给不可访问属性赋值时，如不存在的属性，会被调用。</p><h4 id="call"><a href="#call" class="headerlink" title="__call"></a><code>__call</code></h4><p>在对象中调用一个不可访问方法时，如不存在的方法，<code>__call </code>会被调用。</p><h3 id="0x7可以使用的内置类"><a href="#0x7可以使用的内置类" class="headerlink" title="0x7可以使用的内置类"></a>0x7可以使用的内置类</h3><h3 id="toString"><a href="#toString" class="headerlink" title="__toString"></a><code>__toString</code></h3><h4 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h4><p>适用于php5、7版本</p><p>开启报错的情况下，能够进行XSS攻击</p><p><code>$a=new Exception(&quot;&lt;script&gt; alert(1)&lt;/script&gt;&quot;);</code></p><h4 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h4><p>适用于php7版本</p><p>开启报错的情况下，能够进行XSS攻击</p><p><code>$a=new Error(&quot;&lt;script&gt; alert(1)&lt;/script&gt;&quot;);</code></p><h4 id="call-1"><a href="#call-1" class="headerlink" title="__call"></a><code>__call</code></h4><h4 id="SoapClient类"><a href="#SoapClient类" class="headerlink" title="SoapClient类"></a>SoapClient类</h4><p>php5,php7均存在此类</p><p>可以用来SSRF攻击</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$a = <span class="hljs-keyword">new</span> SoapClient(<span class="hljs-literal">null</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;uri&#x27;</span>=&gt;<span class="hljs-string">&#x27;http://example.com:5555&#x27;</span>, <span class="hljs-string">&#x27;location&#x27;</span>=&gt;<span class="hljs-string">&#x27;http://example.com:5555/aaa&#x27;</span>));$b = serialize($a);<span class="hljs-keyword">echo</span> $b;$c = unserialize($b);$c-&gt;a();</code></pre><p>调用后会将返回结果写到自己的成员变量里</p><p>对于这个类，还存在一个漏洞，这个类允许设置user-agent头部，如果在设置user-agent值得时候写入<code>\r\n</code>，就可以写入任意头部</p><h3 id="0x8-phar的反序列化"><a href="#0x8-phar的反序列化" class="headerlink" title="0x8 phar的反序列化"></a>0x8 phar的反序列化</h3><p>当使用<code>phar://</code>伪协议作为路径打开文件的时候，会将该文件反序列化</p><p>phar文件由四部分组成</p><pre><code class="hljs txt">1、stub:phar文件标识2、a manifest describing the contents以序列化方式存储，用户自定义的meta-data，攻击所用到的地方3、the file contents文件内容4、[optional] a signature for verifying Phar integrity (phar file format only)签名，放在文件末尾</code></pre><p>创建phar文件</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;&#125;$phar=<span class="hljs-keyword">new</span> Phar(<span class="hljs-string">&quot;phar.phar&quot;</span>); <span class="hljs-comment">//在这一步时后缀必须为phar,但在利用时不需要</span>$phar-&gt;startBuffering();<span class="hljs-comment">//在文件开头设置stub,标准格式,可以添加其他文件的头</span>$phar-&gt;setStub(<span class="hljs-string">&quot;GIF89a&quot;</span>.<span class="hljs-string">&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;</span>); <span class="hljs-comment">//插入序列化的meta-data,攻击利用的关键</span>$o=<span class="hljs-keyword">new</span> Foo();$phar-&gt;setMetadata($o); <span class="hljs-comment">//将自定义的meta-data存入mainifest;</span>$phar-&gt;addFromString(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">//添加要压缩的文件</span><span class="hljs-comment">//签名自动计算</span>$phar-&gt;stopBuffering();<span class="hljs-meta">?&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Pickle反序列化</title>
    <link href="/2020/08/22/Python-Pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2020/08/22/Python-Pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="Python-Pickle反序列化"><a href="#Python-Pickle反序列化" class="headerlink" title="Python Pickle反序列化"></a>Python Pickle反序列化</h2><h3 id="0x01-Pickle介绍"><a href="#0x01-Pickle介绍" class="headerlink" title="0x01 Pickle介绍"></a>0x01 Pickle介绍</h3><p>Pickle模块是可以用来序列化和反序列化，可以被操作的对象有</p><pre><code class="hljs txt">None、True、False整数、浮点数、复数str、byte、bytearray只包含可操作对象的tuple、list、set、dict定义在模块最外层的函数（不包含lambda）定义在模块最外层的内置函数定义在模块最外层的类__dict__属性或__getstate__()函数的返回值能够被封存的类</code></pre><p><code>pickle.load</code>从文件读取序列化后的对象，<code>pickle.dump</code>序列化对象到文件</p><p><code>pickle.loads</code>从byte-like object读取序列化后的对象，<code>pickle.dumps</code>将序列化后的对象以bytes类型返回</p><h3 id="0x02-Pickle-原理"><a href="#0x02-Pickle-原理" class="headerlink" title="0x02 Pickle 原理"></a>0x02 Pickle 原理</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>pickle在序列化时只序列化类的名称<code>__class__</code>,和对象属性列表<code>__dict__</code></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span>(<span class="hljs-params">obj</span>):</span>    <span class="hljs-keyword">return</span> (obj.__class__, obj.__dict__)</code></pre><p>也就是说类属性不会被序列化</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>pickle反序列化时并不会调用类的<code>__init__</code>方法,而是使用<code>__new__</code>方法创建实例,然后修改实例的<code>__dict__</code>属性</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span>(<span class="hljs-params">cls, attributes</span>):</span>    obj = cls.__new__(cls)    obj.__dict__.update(attributes)    <span class="hljs-keyword">return</span> obj</code></pre><p>从底层来讲</p><p>Pickle模块维护了两个栈:当前栈,和前序栈,还有一个存储区,这里不看.序列化得到的字节其实类似于由操作码和操作数的字节码.复原一个类的实际操作和上面的load()函数基本相同.我们可以使用pickletools来查看</p><pre><code class="hljs txt">pickletools是python自带的pickle调试器，有三个功能：反汇编一个已经被打包的字符串、优化一个已经被打包的字符串、返回一个迭代器来供程序使用。我们一般使用前两种。</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<span class="hljs-keyword">import</span> pickletools<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.q=<span class="hljs-string">&#x27;w&#x27;</span>        self.p=<span class="hljs-string">&#x27;z&#x27;</span>s=pickle.dumps(A())s=pickletools.optimize(s)print(s)pickletools.dis(s)</code></pre><pre><code class="hljs python">返回结果<span class="hljs-string">b&#x27;\x80\x04\x95!\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x8c\x01A\x93)\x81&#125;(\x8c\x01q\x8c\x01w\x8c\x01p\x8c\x01zub.&#x27;</span>    <span class="hljs-number">0</span>: \x80 PROTO      <span class="hljs-number">4</span>当前协议版本<span class="hljs-number">4</span>    <span class="hljs-number">2</span>: \x95 FRAME      <span class="hljs-number">33</span>接下来为新的栈帧   <span class="hljs-number">11</span>: \x8c SHORT_BINUNICODE <span class="hljs-string">&#x27;__main__&#x27;</span>  压栈__main__   <span class="hljs-number">21</span>: \x8c SHORT_BINUNICODE <span class="hljs-string">&#x27;A&#x27;</span>  压栈A   <span class="hljs-number">24</span>: \x93 STACK_GLOBAL 弹栈两次,压入__main__.A模块   <span class="hljs-number">25</span>: )    EMPTY_TUPLE 压栈空元组()   <span class="hljs-number">26</span>: \x81 NEWOBJ 弹栈两次,分别存入args,cls,执行cls.__new__(cls,())   <span class="hljs-number">27</span>: &#125;    EMPTY_DICT  压栈空字典   <span class="hljs-number">28</span>: (    MARK 将当前栈元素作为列表[A(),&#123;&#125;]压入前序栈,清空当前栈   <span class="hljs-number">29</span>: \x8c     SHORT_BINUNICODE <span class="hljs-string">&#x27;q&#x27;</span>   压栈q   <span class="hljs-number">32</span>: \x8c     SHORT_BINUNICODE <span class="hljs-string">&#x27;w&#x27;</span>   压栈w   <span class="hljs-number">35</span>: \x8c     SHORT_BINUNICODE <span class="hljs-string">&#x27;p&#x27;</span>   压栈p   <span class="hljs-number">38</span>: \x8c     SHORT_BINUNICODE <span class="hljs-string">&#x27;z&#x27;</span>   压栈z   <span class="hljs-number">41</span>: u        SETITEMS   (MARK at <span class="hljs-number">28</span>)    将当前栈的内容存入数组arr=[<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>],然后把当前栈恢复为调用mark前,现在当前栈剩下A(),&#123;&#125;.弹栈(规定是字典),两个一组读取arr,存入弹出的字典   <span class="hljs-number">42</span>: b    BUILD 栈顶存进state,弹栈,栈顶存进inst,弹栈,用state来更新inst,得到的对象压栈   <span class="hljs-number">43</span>: .    STOP                          弹栈结束highest protocol among opcodes = <span class="hljs-number">4</span></code></pre><p>原讲解见<a href="https://zhuanlan.zhihu.com/p/89132768">https://zhuanlan.zhihu.com/p/89132768</a></p><p>pickletools源码中存有详细的操作码介绍</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>awk 用法</title>
    <link href="/2020/08/22/awk-%E7%94%A8%E6%B3%95/"/>
    <url>/2020/08/22/awk-%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="awk使用"><a href="#awk使用" class="headerlink" title="awk使用"></a>awk使用</h2><h3 id="0x1-格式"><a href="#0x1-格式" class="headerlink" title="0x1 格式"></a>0x1 格式</h3><p>awk 选项 ‘BEGIN{action} pattern1 &amp;&amp; pattern2 || pattern3{action1}pattern4{action2;action3}END{action}’ 文件</p><h3 id="0x2-执行流程"><a href="#0x2-执行流程" class="headerlink" title="0x2 执行流程"></a>0x2 执行流程</h3><p>awk首先执行BEGIN代码块</p><p>然后按照RS指定的分隔符从文件中读取文件，RS默认为\n,如果没有指定文件，则从标准输入读取</p><p>每读取一条记录</p><p>都将设置NR,FNR,RT,$0等变量</p><p>（默认）按照FS指定的分隔符分割字段，赋值给$1,$2,$3……$(NF-1),$NF,NF表示字段的个数</p><p>对main代码块的pattern进行匹配，匹配则执行action</p><p>执行END代码块</p><h3 id="0x3分割字段的方法"><a href="#0x3分割字段的方法" class="headerlink" title="0x3分割字段的方法"></a>0x3分割字段的方法</h3><p>在BEGIN中指定对每条记录都有效，</p><p><img src="image-20200921150511908.png" alt="image-20200921150511908"></p><p>在main代码块则只对第二条及以后有效。在对第n行的action中指定，只对对接下来的行有效。</p><p><img src="image-20200921150745821.png" alt="image-20200921150745821"></p><p>可以通过PROCINFO[“FS”]查看</p><p><img src="image-20200921152241706.png" alt="image-20200921152241706"></p><h4 id="FS（默认）"><a href="#FS（默认）" class="headerlink" title="FS（默认）"></a>FS（默认）</h4><p>指定分隔符，默认为空格，默认情况下识别连续空格和其他空白符whitespace</p><p><img src="image-20200921151241855.png" alt="image-20200921151241855"></p><p><img src="image-20200921150949617.png" alt="image-20200921150949617"></p><p>FIELDWIDTHS</p><p>按字符格式分割字段 1 1:1代表第一个字段长度为1,跳过一个字符读取一个字符作为第二个字段，剩下的丢弃，字符读完为止</p><p><img src="image-20200921151549478.png" alt="image-20200921151549478"></p><p><img src="image-20200921151629782.png" alt="image-20200921151629782"></p><h4 id="FPAT"><a href="#FPAT" class="headerlink" title="FPAT"></a>FPAT</h4><p>按照正则表达式匹配字段</p><p><img src="image-20200921151823401.png" alt="image-20200921151823401"></p><h3 id="0x4-一些自带属性"><a href="#0x4-一些自带属性" class="headerlink" title="0x4 一些自带属性"></a>0x4 一些自带属性</h3><p>RS 记录分割     RT    输出时用RT记录进行连接</p><p>FS 字段分割    FT    输出时用FT字段进行连接，<code>，代表FT</code></p><p>FNR   单个输入的行号   NR  所有输入的行号</p><p>NF   字段数</p><p><img src="image-20200921152859320.png" alt="image-20200921152932083"></p><p>0x5 特殊的空值</p><p>awk代码块中未被赋值的参数，会根据它进行的操作是算数运算还是其他运算进行初始化。</p><p><img src="image-20200921153856329.png" alt="image-20200921153856329"></p><p>在处理第一行时，由于a为初始化，a可以为空字符串，0，false,由于前面进行了取反的布尔运算，所以a取false</p><p>取反后为True赋值给a,所以第一行pattern为真。</p>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>owasp top 10</title>
    <link href="/2020/08/21/owasp-top-10/"/>
    <url>/2020/08/21/owasp-top-10/</url>
    
    <content type="html"><![CDATA[<h2 id="owasp-top10漏洞"><a href="#owasp-top10漏洞" class="headerlink" title="owasp top10漏洞"></a>owasp top10漏洞</h2><h3 id="0x1-注入（Injection）"><a href="#0x1-注入（Injection）" class="headerlink" title="0x1 注入（Injection）"></a>0x1 注入（Injection）</h3><p>注入漏洞，例如SQL,NOSQL,OS和LDAP注入，当不可信的数据被当作命令或者查询的一部分解析时出现。攻击者的恶意数据能够让解释器执行意料之外的命令或者绕过授权读取数据。</p><h3 id="0x2-错误的身份验证-Broken-Authentication"><a href="#0x2-错误的身份验证-Broken-Authentication" class="headerlink" title="0x2 错误的身份验证(Broken Authentication)"></a>0x2 错误的身份验证(Broken Authentication)</h3><p>应用的有关身份验证和session管理的实现往往是错误的，这使得攻击者能拿到密码，keys,session tokens，或者让攻击者挖掘其他的漏洞，暂时或永久的冒充其他用户。</p><h3 id="0x3-敏感信息泄露（Sensitive-Data-Exposure）"><a href="#0x3-敏感信息泄露（Sensitive-Data-Exposure）" class="headerlink" title="0x3 敏感信息泄露（Sensitive Data Exposure）"></a>0x3 敏感信息泄露（Sensitive Data Exposure）</h3><p>许多web应用和api没有正确的保护敏感数据，攻击者可能窃取或者修改这些未被保护好的数据，进行信用卡诈骗，身份窃取，或者其他的犯罪行为。敏感数据如果没有进行保护，例如静态、动态加密，在浏览器间传输时实行特别的预防措施，就很可能会泄露。</p><h3 id="0x4-XXE（XML-External-Entities）"><a href="#0x4-XXE（XML-External-Entities）" class="headerlink" title="0x4 XXE（XML External Entities）"></a>0x4 XXE（XML External Entities）</h3><p>许多旧的、配置错误的XML处理器在xml文档里进行外部实体引用。外部实体能够被用来读取服务器内部的文件，通过file协议，还可以进行服务器端口扫描、远程代码执行、拒绝服务攻击。</p><h3 id="0x5-错误的访问控制（Broken-Access-Control）"><a href="#0x5-错误的访问控制（Broken-Access-Control）" class="headerlink" title="0x5 错误的访问控制（Broken Access Control）"></a>0x5 错误的访问控制（Broken Access Control）</h3><p>被授权用户的行为往往没有被正确的限制。攻击者可以利用这些漏洞访问未授权的功能，或者读取不属于他的数据，例如访问其他用户的帐号，访问敏感文件，修改其他用户的数据，更改访问权限等</p><h3 id="0x6-错误的安全配置（Security-Misconfiguration）"><a href="#0x6-错误的安全配置（Security-Misconfiguration）" class="headerlink" title="0x6 错误的安全配置（Security Misconfiguration）"></a>0x6 错误的安全配置（Security Misconfiguration）</h3><p>错误的安全配置是最常见的问题。往往是由于使用了默认的不安全的配置。厂商不仅需要根据不同操作系统、框架、库和应用来进行安全配置，而且这些配置要按时更新，打补丁。</p><h3 id="0x7跨站脚本攻击（Cross-Site-Scripting-Xss）"><a href="#0x7跨站脚本攻击（Cross-Site-Scripting-Xss）" class="headerlink" title="0x7跨站脚本攻击（Cross-Site Scripting Xss）"></a>0x7跨站脚本攻击（Cross-Site Scripting Xss）</h3><p>XSS漏洞的存在</p><p>1、在新的web页面包含不可信的数据，没有进行正确的验证和转义</p><p>2、通过可以创建HTML或者JS的浏览器API，用用户提交的数据更新web页面</p><p>XSS让攻击者能够在victim的浏览器上执行代码，XSS能够劫持用户的session,污染网站，或者将用户重定向到恶意网站（可以和CSRF漏洞配合）</p><h3 id="0x8不安全的反序列化（Insecure-Deserialization）"><a href="#0x8不安全的反序列化（Insecure-Deserialization）" class="headerlink" title="0x8不安全的反序列化（Insecure Deserialization）"></a>0x8不安全的反序列化（Insecure Deserialization）</h3><p>不安全的反序列化往往导致了远程代码执行。即使反序列化漏洞没有导致远程代码执行，也能够被用来辅助攻击，包括重放攻击，注入攻击，越权攻击</p><h3 id="0x9使用有公开漏洞的组件（Using-Components-with-Known-Vulnerablilities）"><a href="#0x9使用有公开漏洞的组件（Using-Components-with-Known-Vulnerablilities）" class="headerlink" title="0x9使用有公开漏洞的组件（Using Components with Known Vulnerablilities）"></a>0x9使用有公开漏洞的组件（Using Components with Known Vulnerablilities）</h3><p>组件，例如函数库，框架和其他的软件模块，他们都和web应用有一样的权限。如果使用了一个vulnerable的组件，对他的攻击会帮助攻击者，造成严重的数据丢失或者攻击者接管服务器。使用有已知安全漏洞的组件会破坏已有的安全防线，导致各种攻击。</p><h3 id="0x10-无效的日志或监视（Insufficient-Logging-amp-Monitoring）"><a href="#0x10-无效的日志或监视（Insufficient-Logging-amp-Monitoring）" class="headerlink" title="0x10 无效的日志或监视（Insufficient Logging &amp; Monitoring）"></a>0x10 无效的日志或监视（Insufficient Logging &amp; Monitoring）</h3><p>无效的日志或者监视，加上没有应急响应（或者是低效的），使攻击者能够持续攻击系统，维持权限，然后转向更多的系统。攻击者能够篡改，收集，毁坏victim的数据。大多数的研究表明检测到数据泄露（data breach）的时间超过200天。</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcp/ip网络模型</title>
    <link href="/2020/08/19/tcp-ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/08/19/tcp-ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="tcp-ip-网络模型"><a href="#tcp-ip-网络模型" class="headerlink" title="tcp/ip 网络模型"></a>tcp/ip 网络模型</h2><p>分为五层，从上到下为应用层、传输层、网络层、数据链路层、物理层。</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h4 id="http（超文本传输协议）"><a href="#http（超文本传输协议）" class="headerlink" title="http（超文本传输协议）"></a>http（超文本传输协议）</h4><p>可以通过<code>curl url -v</code>查看一次完整的http请求过程</p><p><img src="image-20200919173124218.png" alt="image-20200919173124218"> </p><p>以上的流程可以总结为：</p><p>1、和服务器的端口建立tcp链接（默认为80端口）</p><p>2、发送http请求，包含请求头和请求体，请求头包含多个键值对<code>key1:value1</code>每行以<code>\r\n</code>分割，当遇到两个<code>\r\n</code>表示请求头的结束，接下来全是请求体</p><p>3、服务器返回响应，包含响应头和响应体，格式与http请求基本相同</p><p>4、和服务器断开tcp链接</p><h4 id="dns（域名系统）"><a href="#dns（域名系统）" class="headerlink" title="dns（域名系统）"></a>dns（域名系统）</h4><p>由于32位二进制的ip地址十分难记，我们使用域名来方便记忆。但是计算机不认识域名，前辈们就开发了dns域名系统，实现域名和ip的转换。</p><p>由于计算机无法理解dns系统之间的交流方式，所以通常通过一个resolver来和域名系统交流。我们将dns请求发给resolver,resolver来和dns交流，并返回给我们一个ip。查询域名为 <a href="http://www.example.com/">www.example.com</a> 的ip，完整的交流过程为：</p><p>1、计算机将dns请求发给resolver</p><p>2、resolver询问根服务器，根服务器不知道，但是.com服务器知道。</p><p>3、于是resolver询问com服务器，com服务器表示exmaple.com知道</p><p>4、询问example.com,得到ip地址</p><p>当然，由于缓存的存在，通常我们不需要走完全程，例如resolver缓存了dns查询记录，我们直接就可以拿到结果。再比如我们缓存了com服务器知道结果，则直接询问com服务器。</p><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>使用公私钥加密方式，提供安全的隧道。</p><h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><h4 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h4><p>tcp报文记录了源端口和目的端口</p><p>端口一共有65535个，前1024个为公认端口，他们紧密绑定了一些服务。只有root有权限控制。</p><p>发送http请求时，源端口为系统任意选择大于1024的任意端口，目的端口默认为80</p><p>握手过程分为三步</p><p>1、客户端发送<code>SYN=x</code>，请求建立连接，客户端状态为syn-send</p><p>2、服务器收到，发送<code>SYN=y,ACK=x+1</code>,服务器状态为syn-received</p><p>3、客户端收到请求，发送<code>ACK=y+1</code>,连接建立</p><p>对于tcp的实现socket来说</p><p>服务端</p><p>1、使用socket创建监听套接字listenfd，调用bind绑定端口，调用listen监听端口,监听之后，套接字从CLOSED状态变为LISTEN状态</p><p>2、收到客户端发来的SYN报文，回复SYN+ACK,这时在未完成连接队列中创建一个新项目,并设置为SYN_RECV状态，然后继续监听listenfd</p><p>3、再次收到对应的ACK报文,把连接未完成队列中的项目移入连接已完成队列，并设置为ESTABLISHED状态</p><p>4、服务器通过accept进行消费，从已完成队列中拿取连接</p><p>netstat命令的Recv-Q和Send-Q表示的就是socket buffer相关的内容</p><p>对于监听状态的套接字，Recv-Q表示的是未完成队列中的连接个数，Send-Q表示的是未完成连接队列的最大连接限制个数</p><p>对于已经建立的tcp连接，Recv-Q列表示的是recv buffer中还未被用户进程拷贝走的数据大小，</p><p>Send-Q表示的是远程主机还未返回ACK消息的数据大小</p><p><img src="image-20200919185139646.png" alt="image-20200919185139646"> </p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><p>ipv4地址由32位二进制表示，也可以每八位一组来表示。</p><p>IP地址范围为0.0.0.0-255.255.255.255</p><p>其中10.0.0.0～10.255.255.255、172.16.0.0～172.16.255.255、192.168.0.0～192.168.255.255为内网地址，在公网上不分配，127开头的为环回地址，代表本机。</p><p>主机号全为0的表示直接广播地址，主机号全为1的表示受限广播地址，区别为广播是否会被发给路由器。</p><h4 id="icmp"><a href="#icmp" class="headerlink" title="icmp"></a>icmp</h4><p>icmp报文包含在ip报文中，头部的type说明icmp报文的作用</p><p>常见的type有</p><p>0：echo reply ping 应答</p><p>8：echo request ping请求</p><h4 id="ipsec"><a href="#ipsec" class="headerlink" title="ipsec"></a>ipsec</h4>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SESSION_UPLOAD_PROGRESS利用</title>
    <link href="/2019/09/22/SESSION-UPLOAD-PROGRESS%E5%88%A9%E7%94%A8/"/>
    <url>/2019/09/22/SESSION-UPLOAD-PROGRESS%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="SESSION-UPLOAD-PROGRESS利用"><a href="#SESSION-UPLOAD-PROGRESS利用" class="headerlink" title="SESSION_UPLOAD_PROGRESS利用"></a>SESSION_UPLOAD_PROGRESS利用</h1><h3 id="0x01-前提"><a href="#0x01-前提" class="headerlink" title="0x01 前提"></a>0x01 前提</h3><p><img src="image-20200922163534450.png" alt="image-20200922163534450"></p><pre><code class="hljs php">session.upload_progress.enabled=Onsession.serialize_handler在php_serialize和其他两种之间进行过切换PS:serialize_handler存在三种    php:键名|经过serialize()函数序列化的值    php_serialize(php&gt;<span class="hljs-number">5.5</span><span class="hljs-number">.4</span>):serialize()函数序列化的值    php_binary:键名的长度对应的ascii字符+键名+经过serialize()函数序列化的值</code></pre><h3 id="0x02-session-upload-progress介绍"><a href="#0x02-session-upload-progress介绍" class="headerlink" title="0x02 session upload progress介绍"></a>0x02 session upload progress介绍</h3><p>当<code>session.upload_progress.enable=On</code>时,php能在上传文件时检测上传进度.</p><p>当上传文件在处理中时,同时POST一个与<code>session.upload_progress.name=SESSION_UPLOAD_PROGRESS</code>同名的变量时,会将上传进度信息写入Session,他会在$_SESSION中添加一组数据,索引是<code>session.upload_progress.prefix和session.upload_progress.name连接在一起的值</code></p><p>我们还知道,php的Session信息会被写入sess_$PHPSESSID文件中,这代表着我们能向服务器的session.save_path路径下写入文件</p><h3 id="0x03-脚本"><a href="#0x03-脚本" class="headerlink" title="0x03 脚本"></a>0x03 脚本</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsurl=<span class="hljs-string">&quot;&quot;</span>payload=<span class="hljs-string">&quot;123&quot;</span>files=&#123;<span class="hljs-string">&quot;file&quot;</span>:(<span class="hljs-string">&quot;filename&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;image/png&quot;</span>)&#125;data=&#123;    <span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span>:payload&#125;s=requests.session()resp=s.post(url,data=data,files=files)</code></pre><h3 id="0x04达成效果"><a href="#0x04达成效果" class="headerlink" title="0x04达成效果"></a>0x04达成效果</h3><p>在<code>session.save_path</code>路径下上传了文件名为<code>sess_$PHPSESSID</code>的文件,可以向该文件写入任何内容,并且在php读取session文件时,会反序列化该文件.</p><pre><code class="hljs pgsql">注:在<span class="hljs-keyword">session</span>.serialize_handler不为php_serialize时,<span class="hljs-string">&#x27;|&#x27;</span>是被禁止写入的.反序列化漏洞利用的关键就是使用<span class="hljs-string">&#x27;|&#x27;</span>分割字段</code></pre><h3 id="0x05-注意"><a href="#0x05-注意" class="headerlink" title="0x05 注意"></a>0x05 注意</h3><p><code>session.upload_progress.cleanup</code>开启时,会在文件上传完毕后删除对应的session文件.利用时可以使用大文件和条件竞争.在session文件未被删除前利用.</p>]]></content>
    
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
