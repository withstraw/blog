<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python Requests库简单使用</title>
    <link href="/2020/09/21/Python-Requests%E5%BA%93%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/21/Python-Requests%E5%BA%93%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Python-Requests库简单使用"><a href="#Python-Requests库简单使用" class="headerlink" title="Python Requests库简单使用"></a>Python Requests库简单使用</h2><h3 id="0x1-requests-get"><a href="#0x1-requests-get" class="headerlink" title="0x1 requests.get"></a>0x1 requests.get</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsurl=<span class="hljs-string">&#x27;http://www.exmaple.com&#x27;</span>headers=&#123;    <span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;r=requests.get(url)<span class="hljs-comment">#自定义请求头</span>r=requests.get(url,headers=headers)r.status_code  <span class="hljs-comment">#状态吗</span>r.content   <span class="hljs-comment">#二进制字节码</span>r.text       <span class="hljs-comment">#文本格式响应</span></code></pre><h3 id="0x2-requests-post"><a href="#0x2-requests-post" class="headerlink" title="0x2 requests.post"></a>0x2 requests.post</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsdata=&#123;<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;cookies=&#123;<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;files=&#123;<span class="hljs-string">&quot;foo1&quot;</span>:<span class="hljs-string">&quot;filelikeobject&quot;</span><span class="hljs-string">&quot;foo2&quot;</span>:(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;/imge/png&quot;</span>)&#125;url=<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span><span class="hljs-comment">#上传数据</span>r=requests.post(url,data=<span class="hljs-string">&quot;l am in body&quot;</span>)<span class="hljs-comment">#上传表单数据</span>r=requests.post(url,data=data)<span class="hljs-comment">#上传文件</span>r=requests.post(url,files=files)<span class="hljs-comment">#带有cookies</span>r=requests.post(url,cookies=cookies)r.text</code></pre><h3 id="0x3-session"><a href="#0x3-session" class="headerlink" title="0x3 session"></a>0x3 session</h3><pre><code class="hljs routeros">import requests<span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;http://httpbin.org&quot;</span><span class="hljs-attribute">s</span>=requests.session()s.<span class="hljs-builtin-name">get</span>(url)s.post(url)</code></pre><pre><code class="hljs qml"><span class="hljs-keyword">import</span> requests<span class="hljs-built_in">url</span>=<span class="hljs-string">&quot;http://httpbin.org&quot;</span><span class="hljs-keyword">with</span> requests.Session() <span class="hljs-keyword">as</span> <span class="hljs-attribute">s</span>:s.get(<span class="hljs-built_in">url</span>)s.post(<span class="hljs-built_in">url</span>)</code></pre><p>0x4 proxy</p><pre><code class="hljs makefile">import requestsurl=<span class="hljs-string">&quot;http://httpbin.org&quot;</span>proxies=&#123;<span class="hljs-string">&quot;http&quot;</span>:<span class="hljs-string">&quot;127.0.0.1:7777&quot;</span>,<span class="hljs-string">&quot;https&quot;</span>:<span class="hljs-string">&quot;127.0.0.1:777&quot;</span>&#125;r=requests.get(url,proxies=proxies)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php 反序列化漏洞</title>
    <link href="/2020/08/22/php-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2020/08/22/php-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="php-反序列化漏洞"><a href="#php-反序列化漏洞" class="headerlink" title="php 反序列化漏洞"></a>php 反序列化漏洞</h2><h3 id="0x1整型的序列化"><a href="#0x1整型的序列化" class="headerlink" title="0x1整型的序列化"></a>0x1整型的序列化</h3><p><img src="image-20200921170331985.png" alt="image-20200921170331985"> </p><p>结果为<code>i:1;</code></p><p>i代表类型为整型，1为值</p><p>整型的序列化结果为<code>i:值;</code></p><h3 id="0x2字符串序列化"><a href="#0x2字符串序列化" class="headerlink" title="0x2字符串序列化"></a>0x2字符串序列化</h3><p><img src="image-20200921165623154.png" alt="image-20200921165623154"></p><p>结果为<code>s:6:&quot;string&quot;;</code> </p><p>s代表类型为字符串,6代表长度，string为值</p><p>字符串的序列化结果<code>s:长度:值;</code></p><h3 id="0x3-数组序列化"><a href="#0x3-数组序列化" class="headerlink" title="0x3 数组序列化"></a>0x3 数组序列化</h3><p><img src="image-20200921165824145.png" alt="image-20200921165824145"></p><p>结果为<code>a:1:&#123;s:3:&quot;foo&quot;;s:3:&quot;bar&quot;&#125;</code></p><p>a代表类型为数组，1代表数组长度，接着为值</p><p>s代表键的类型，3代表键的长度，接着为值</p><p>s代表值的类型，3代表值的长度，接着为值</p><p>数组的序列化结果<code>a:数组长度:&#123;键的序列化结果 值的序列化结果    键的序列化结果 值的序列化结果……&#125;</code></p><h3 id="0x4类的序列化结果"><a href="#0x4类的序列化结果" class="headerlink" title="0x4类的序列化结果"></a>0x4类的序列化结果</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span></span>&#123;    <span class="hljs-keyword">const</span> constant=<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">public</span> $bar1=<span class="hljs-number">1</span>;<span class="hljs-keyword">protected</span> $bar2=<span class="hljs-string">&#x27;2&#x27;</span>;<span class="hljs-keyword">private</span> $bar3=[<span class="hljs-string">&#x27;3&#x27;</span>];&#125;$f=<span class="hljs-keyword">new</span> foo();$s=serialize($f);<span class="hljs-keyword">echo</span> str_replace(chr(<span class="hljs-number">0</span>),<span class="hljs-string">&#x27;%00&#x27;</span>,$s).PHP_EOL;<span class="hljs-comment">#为了便于观看，将不可见的0x00变为%00</span></code></pre><p>结果为</p><pre><code class="hljs php">O:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;bar1&quot;</span>;i:<span class="hljs-number">1</span>;s:<span class="hljs-number">7</span>:<span class="hljs-string">&quot;%00*%00bar2&quot;</span>;s:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;2&quot;</span>;s:<span class="hljs-number">9</span>:<span class="hljs-string">&quot;%00foo%00bar3&quot;</span>;a:<span class="hljs-number">1</span>:&#123;i:<span class="hljs-number">0</span>;s:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;3&quot;</span>;&#125;&#125;</code></pre><p>O代表类型为对象，3为类的名称长度，foo为类的名称</p><p>接下来依次是类的成员变量名称与值的序列化结果，可以看到他们的名称发生了变化，这种变化与关键字protected,public,private有关</p><p>成员变量bar1为public,他的名称没有变化</p><p>成员变量bar2为protected,他的名称变为了<code>%00*%00bar2</code>,bar2为原来的名称</p><p>成员变量bar3为private,他的名称变为了<code>%00foo%00bar3</code>，foo为类名，bar3为原来的名称</p><p>对象的序列化结果<code>O:类名长度:类名:&#123;成员变量键序列化结果 成员变量值序列化结果 ……&#125;</code></p><p>其中成员变量键序列化结果有所不同 </p><p><code>protected 类型:键长度:%00*%00键名</code></p><p><code>private 类型:键长度:%00类名%00键名</code></p><h3 id="0x5-与反序列化有关的魔术方法-wakeup-sleep"><a href="#0x5-与反序列化有关的魔术方法-wakeup-sleep" class="headerlink" title="0x5 与反序列化有关的魔术方法 __wakeup,__sleep"></a>0x5 与反序列化有关的魔术方法 <code>__wakeup,__sleep</code></h3><p><code>__sleep</code>在对象被序列化时调用，返回包含对象中所有应被序列化的变量名称的数组（按照规定）</p><p><code>__wakeup</code>在对象被反序列化时调用，通常进行初始化操作，如果序列化字符串的个数出错，则不会调用。可以用于绕过<code>__wakeup</code>函数中的检查。</p><h3 id="0x6-一些可以利用的魔术方法-toString-invoke-callable-get-set"><a href="#0x6-一些可以利用的魔术方法-toString-invoke-callable-get-set" class="headerlink" title="0x6 一些可以利用的魔术方法 __toString,__invoke,__callable,__get,__set"></a>0x6 一些可以利用的魔术方法 <code>__toString,__invoke,__callable,__get,__set</code></h3><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString"></a>__toString</h4><p>当一个类被当作字符串时，会调用该方法。此方法必须返回一个字符串。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span></span>&#123;<span class="hljs-keyword">public</span> $bar1=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;&#125;&#125;$f=<span class="hljs-keyword">new</span> foo();<span class="hljs-keyword">echo</span> $f.PHP_EOL;</code></pre><p><img src="image-20200921173027418.png" alt="image-20200921173027418"></p><h4 id="invoke"><a href="#invoke" class="headerlink" title="__invoke"></a>__invoke</h4><p>当尝试以调用一个函数的方式调用一个对象，会调用该方法</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span></span>&#123;<span class="hljs-keyword">public</span> $bar1=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params">$x</span>)</span>&#123;var_dump($x);&#125;&#125;$f=<span class="hljs-keyword">new</span> foo();$f(<span class="hljs-number">10</span>);var_dump(is_callable($f));</code></pre><p>输出</p><p><img src="image-20200921173333544.png" alt="image-20200921173333544"></p><h4 id="get"><a href="#get" class="headerlink" title="__get"></a>__get</h4><p>在访问不可访问属性赋值时，如不存在的属性，会被调用。</p><h4 id="set"><a href="#set" class="headerlink" title="__set"></a>__set</h4><p>在给不可访问属性赋值时，如不存在的属性，会被调用。</p><h4 id="call"><a href="#call" class="headerlink" title="__call"></a><code>__call</code></h4><p>在对象中调用一个不可访问方法时，如不存在的方法，<code>__call </code>会被调用。</p><h3 id="0x7可以使用的内置类"><a href="#0x7可以使用的内置类" class="headerlink" title="0x7可以使用的内置类"></a>0x7可以使用的内置类</h3><h3 id="toString"><a href="#toString" class="headerlink" title="__toString"></a><code>__toString</code></h3><h4 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h4><p>适用于php5、7版本</p><p>开启报错的情况下，能够进行XSS攻击</p><p><code>$a=new Exception(&quot;&lt;script&gt; alert(1)&lt;/script&gt;&quot;);</code></p><h4 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h4><p>适用于php7版本</p><p>开启报错的情况下，能够进行XSS攻击</p><p><code>$a=new Error(&quot;&lt;script&gt; alert(1)&lt;/script&gt;&quot;);</code></p><h4 id="call-1"><a href="#call-1" class="headerlink" title="__call"></a><code>__call</code></h4><h4 id="SoapClient类"><a href="#SoapClient类" class="headerlink" title="SoapClient类"></a>SoapClient类</h4><p>php5,php7均存在此类</p><p>可以用来SSRF攻击</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$a = <span class="hljs-keyword">new</span> SoapClient(<span class="hljs-literal">null</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;uri&#x27;</span>=&gt;<span class="hljs-string">&#x27;http://example.com:5555&#x27;</span>, <span class="hljs-string">&#x27;location&#x27;</span>=&gt;<span class="hljs-string">&#x27;http://example.com:5555/aaa&#x27;</span>));$b = serialize($a);<span class="hljs-keyword">echo</span> $b;$c = unserialize($b);$c-&gt;a();</code></pre><p>调用后会将返回结果写到自己的成员变量里</p><p>对于这个类，还存在一个漏洞，这个类允许设置user-agent头部，如果在设置user-agent值得时候写入<code>\r\n</code>，就可以写入任意头部</p><h3 id="0x8-phar的反序列化"><a href="#0x8-phar的反序列化" class="headerlink" title="0x8 phar的反序列化"></a>0x8 phar的反序列化</h3><p>当使用<code>phar://</code>伪协议作为路径打开文件的时候，会将该文件反序列化</p><p>phar文件由四部分组成</p><pre><code class="hljs txt">1、stub:phar文件标识2、a manifest describing the contents以序列化方式存储，用户自定义的meta-data，攻击所用到的地方3、the file contents文件内容4、[optional] a signature for verifying Phar integrity (phar file format only)签名，放在文件末尾</code></pre><p>创建phar文件</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;&#125;$phar=<span class="hljs-keyword">new</span> Phar(<span class="hljs-string">&quot;phar.phar&quot;</span>); <span class="hljs-comment">//在这一步时后缀必须为phar,但在利用时不需要</span>$phar-&gt;startBuffering();<span class="hljs-comment">//在文件开头设置stub,标准格式,可以添加其他文件的头</span>$phar-&gt;setStub(<span class="hljs-string">&quot;GIF89a&quot;</span>.<span class="hljs-string">&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;</span>); <span class="hljs-comment">//插入序列化的meta-data,攻击利用的关键</span>$o=<span class="hljs-keyword">new</span> Foo();$phar-&gt;setMetadata($o); <span class="hljs-comment">//将自定义的meta-data存入mainifest;</span>$phar-&gt;addFromString(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">//添加要压缩的文件</span><span class="hljs-comment">//签名自动计算</span>$phar-&gt;stopBuffering();<span class="hljs-meta">?&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>awk 用法</title>
    <link href="/2020/08/22/awk-%E7%94%A8%E6%B3%95/"/>
    <url>/2020/08/22/awk-%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="awk使用"><a href="#awk使用" class="headerlink" title="awk使用"></a>awk使用</h2><h3 id="0x1-格式"><a href="#0x1-格式" class="headerlink" title="0x1 格式"></a>0x1 格式</h3><p>awk 选项 ‘BEGIN{action} pattern1 &amp;&amp; pattern2 || pattern3{action1}pattern4{action2;action3}END{action}’ 文件</p><h3 id="0x2-执行流程"><a href="#0x2-执行流程" class="headerlink" title="0x2 执行流程"></a>0x2 执行流程</h3><p>awk首先执行BEGIN代码块</p><p>然后按照RS指定的分隔符从文件中读取文件，RS默认为\n,如果没有指定文件，则从标准输入读取</p><p>每读取一条记录</p><p>都将设置NR,FNR,RT,$0等变量</p><p>（默认）按照FS指定的分隔符分割字段，赋值给$1,$2,$3……$(NF-1),$NF,NF表示字段的个数</p><p>对main代码块的pattern进行匹配，匹配则执行action</p><p>执行END代码块</p><h3 id="0x3分割字段的方法"><a href="#0x3分割字段的方法" class="headerlink" title="0x3分割字段的方法"></a>0x3分割字段的方法</h3><p>在BEGIN中指定对每条记录都有效，</p><p><img src="image-20200921150511908.png" alt="image-20200921150511908"></p><p>在main代码块则只对第二条及以后有效。在对第n行的action中指定，只对对接下来的行有效。</p><p><img src="image-20200921150745821.png" alt="image-20200921150745821"></p><p>可以通过PROCINFO[“FS”]查看</p><p><img src="image-20200921152241706.png" alt="image-20200921152241706"></p><h4 id="FS（默认）"><a href="#FS（默认）" class="headerlink" title="FS（默认）"></a>FS（默认）</h4><p>指定分隔符，默认为空格，默认情况下识别连续空格和其他空白符whitespace</p><p><img src="image-20200921151241855.png" alt="image-20200921151241855"></p><p><img src="image-20200921150949617.png" alt="image-20200921150949617"></p><p>FIELDWIDTHS</p><p>按字符格式分割字段 1 1:1代表第一个字段长度为1,跳过一个字符读取一个字符作为第二个字段，剩下的丢弃，字符读完为止</p><p><img src="image-20200921151549478.png" alt="image-20200921151549478"></p><p><img src="image-20200921151629782.png" alt="image-20200921151629782"></p><h4 id="FPAT"><a href="#FPAT" class="headerlink" title="FPAT"></a>FPAT</h4><p>按照正则表达式匹配字段</p><p><img src="image-20200921151823401.png" alt="image-20200921151823401"></p><h3 id="0x4-一些自带属性"><a href="#0x4-一些自带属性" class="headerlink" title="0x4 一些自带属性"></a>0x4 一些自带属性</h3><p>RS 记录分割     RT    输出时用RT记录进行连接</p><p>FS 字段分割    FT    输出时用FT字段进行连接，<code>，代表FT</code></p><p>FNR   单个输入的行号   NR  所有输入的行号</p><p>NF   字段数</p><p><img src="image-20200921152859320.png" alt="image-20200921152932083"></p><p>0x5 特殊的空值</p><p>awk代码块中未被赋值的参数，会根据它进行的操作是算数运算还是其他运算进行初始化。</p><p><img src="image-20200921153856329.png" alt="image-20200921153856329"></p><p>在处理第一行时，由于a为初始化，a可以为空字符串，0，false,由于前面进行了取反的布尔运算，所以a取false</p><p>取反后为True赋值给a,所以第一行pattern为真。</p>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>owasp top 10</title>
    <link href="/2020/08/21/owasp-top-10/"/>
    <url>/2020/08/21/owasp-top-10/</url>
    
    <content type="html"><![CDATA[<h2 id="owasp-top10漏洞"><a href="#owasp-top10漏洞" class="headerlink" title="owasp top10漏洞"></a>owasp top10漏洞</h2><h3 id="0x1-注入（Injection）"><a href="#0x1-注入（Injection）" class="headerlink" title="0x1 注入（Injection）"></a>0x1 注入（Injection）</h3><p>注入漏洞，例如SQL,NOSQL,OS和LDAP注入，当不可信的数据被当作命令或者查询的一部分解析时出现。攻击者的恶意数据能够让解释器执行意料之外的命令或者绕过授权读取数据。</p><h3 id="0x2-错误的身份验证-Broken-Authentication"><a href="#0x2-错误的身份验证-Broken-Authentication" class="headerlink" title="0x2 错误的身份验证(Broken Authentication)"></a>0x2 错误的身份验证(Broken Authentication)</h3><p>应用的有关身份验证和session管理的实现往往是错误的，这使得攻击者能拿到密码，keys,session tokens，或者让攻击者挖掘其他的漏洞，暂时或永久的冒充其他用户。</p><h3 id="0x3-敏感信息泄露（Sensitive-Data-Exposure）"><a href="#0x3-敏感信息泄露（Sensitive-Data-Exposure）" class="headerlink" title="0x3 敏感信息泄露（Sensitive Data Exposure）"></a>0x3 敏感信息泄露（Sensitive Data Exposure）</h3><p>许多web应用和api没有正确的保护敏感数据，攻击者可能窃取或者修改这些未被保护好的数据，进行信用卡诈骗，身份窃取，或者其他的犯罪行为。敏感数据如果没有进行保护，例如静态、动态加密，在浏览器间传输时实行特别的预防措施，就很可能会泄露。</p><h3 id="0x4-XXE（XML-External-Entities）"><a href="#0x4-XXE（XML-External-Entities）" class="headerlink" title="0x4 XXE（XML External Entities）"></a>0x4 XXE（XML External Entities）</h3><p>许多旧的、配置错误的XML处理器在xml文档里进行外部实体引用。外部实体能够被用来读取服务器内部的文件，通过file协议，还可以进行服务器端口扫描、远程代码执行、拒绝服务攻击。</p><h3 id="0x5-错误的访问控制（Broken-Access-Control）"><a href="#0x5-错误的访问控制（Broken-Access-Control）" class="headerlink" title="0x5 错误的访问控制（Broken Access Control）"></a>0x5 错误的访问控制（Broken Access Control）</h3><p>被授权用户的行为往往没有被正确的限制。攻击者可以利用这些漏洞访问未授权的功能，或者读取不属于他的数据，例如访问其他用户的帐号，访问敏感文件，修改其他用户的数据，更改访问权限等</p><h3 id="0x6-错误的安全配置（Security-Misconfiguration）"><a href="#0x6-错误的安全配置（Security-Misconfiguration）" class="headerlink" title="0x6 错误的安全配置（Security Misconfiguration）"></a>0x6 错误的安全配置（Security Misconfiguration）</h3><p>错误的安全配置是最常见的问题。往往是由于使用了默认的不安全的配置。厂商不仅需要根据不同操作系统、框架、库和应用来进行安全配置，而且这些配置要按时更新，打补丁。</p><h3 id="0x7跨站脚本攻击（Cross-Site-Scripting-Xss）"><a href="#0x7跨站脚本攻击（Cross-Site-Scripting-Xss）" class="headerlink" title="0x7跨站脚本攻击（Cross-Site Scripting Xss）"></a>0x7跨站脚本攻击（Cross-Site Scripting Xss）</h3><p>XSS漏洞的存在</p><p>1、在新的web页面包含不可信的数据，没有进行正确的验证和转义</p><p>2、通过可以创建HTML或者JS的浏览器API，用用户提交的数据更新web页面</p><p>XSS让攻击者能够在victim的浏览器上执行代码，XSS能够劫持用户的session,污染网站，或者将用户重定向到恶意网站（可以和CSRF漏洞配合）</p><h3 id="0x8不安全的反序列化（Insecure-Deserialization）"><a href="#0x8不安全的反序列化（Insecure-Deserialization）" class="headerlink" title="0x8不安全的反序列化（Insecure Deserialization）"></a>0x8不安全的反序列化（Insecure Deserialization）</h3><p>不安全的反序列化往往导致了远程代码执行。即使反序列化漏洞没有导致远程代码执行，也能够被用来辅助攻击，包括重放攻击，注入攻击，越权攻击</p><h3 id="0x9使用有公开漏洞的组件（Using-Components-with-Known-Vulnerablilities）"><a href="#0x9使用有公开漏洞的组件（Using-Components-with-Known-Vulnerablilities）" class="headerlink" title="0x9使用有公开漏洞的组件（Using Components with Known Vulnerablilities）"></a>0x9使用有公开漏洞的组件（Using Components with Known Vulnerablilities）</h3><p>组件，例如函数库，框架和其他的软件模块，他们都和web应用有一样的权限。如果使用了一个vulnerable的组件，对他的攻击会帮助攻击者，造成严重的数据丢失或者攻击者接管服务器。使用有已知安全漏洞的组件会破坏已有的安全防线，导致各种攻击。</p><h3 id="0x10-无效的日志或监视（Insufficient-Logging-amp-Monitoring）"><a href="#0x10-无效的日志或监视（Insufficient-Logging-amp-Monitoring）" class="headerlink" title="0x10 无效的日志或监视（Insufficient Logging &amp; Monitoring）"></a>0x10 无效的日志或监视（Insufficient Logging &amp; Monitoring）</h3><p>无效的日志或者监视，加上没有应急响应（或者是低效的），使攻击者能够持续攻击系统，维持权限，然后转向更多的系统。攻击者能够篡改，收集，毁坏victim的数据。大多数的研究表明检测到数据泄露（data breach）的时间超过200天。</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcp/ip网络模型</title>
    <link href="/2020/08/19/tcp-ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/08/19/tcp-ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="tcp-ip-网络模型"><a href="#tcp-ip-网络模型" class="headerlink" title="tcp/ip 网络模型"></a>tcp/ip 网络模型</h2><p>分为五层，从上到下为应用层、传输层、网络层、数据链路层、物理层。</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h4 id="http（超文本传输协议）"><a href="#http（超文本传输协议）" class="headerlink" title="http（超文本传输协议）"></a>http（超文本传输协议）</h4><p>可以通过<code>curl url -v</code>查看一次完整的http请求过程</p><p><img src="image-20200919173124218.png" alt="image-20200919173124218"> </p><p>以上的流程可以总结为：</p><p>1、和服务器的端口建立tcp链接（默认为80端口）</p><p>2、发送http请求，包含请求头和请求体，请求头包含多个键值对<code>key1:value1</code>每行以<code>\r\n</code>分割，当遇到两个<code>\r\n</code>表示请求头的结束，接下来全是请求体</p><p>3、服务器返回响应，包含响应头和响应体，格式与http请求基本相同</p><p>4、和服务器断开tcp链接</p><h4 id="dns（域名系统）"><a href="#dns（域名系统）" class="headerlink" title="dns（域名系统）"></a>dns（域名系统）</h4><p>由于32位二进制的ip地址十分难记，我们使用域名来方便记忆。但是计算机不认识域名，前辈们就开发了dns域名系统，实现域名和ip的转换。</p><p>由于计算机无法理解dns系统之间的交流方式，所以通常通过一个resolver来和域名系统交流。我们将dns请求发给resolver,resolver来和dns交流，并返回给我们一个ip。查询域名为 <a href="http://www.example.com/">www.example.com</a> 的ip，完整的交流过程为：</p><p>1、计算机将dns请求发给resolver</p><p>2、resolver询问根服务器，根服务器不知道，但是.com服务器知道。</p><p>3、于是resolver询问com服务器，com服务器表示exmaple.com知道</p><p>4、询问example.com,得到ip地址</p><p>当然，由于缓存的存在，通常我们不需要走完全程，例如resolver缓存了dns查询记录，我们直接就可以拿到结果。再比如我们缓存了com服务器知道结果，则直接询问com服务器。</p><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>使用公私钥加密方式，提供安全的隧道。</p><h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><h4 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h4><p>tcp报文记录了源端口和目的端口</p><p>端口一共有65535个，前1024个为公认端口，他们紧密绑定了一些服务。只有root有权限控制。</p><p>发送http请求时，源端口为系统任意选择大于1024的任意端口，目的端口默认为80</p><p>握手过程分为三步</p><p>1、客户端发送<code>SYN=x</code>，请求建立连接，客户端状态为syn-send</p><p>2、服务器收到，发送<code>SYN=y,ACK=x+1</code>,服务器状态为syn-received</p><p>3、客户端收到请求，发送<code>ACK=y+1</code>,连接建立</p><p>对于tcp的实现socket来说</p><p>服务端</p><p>1、使用socket创建监听套接字listenfd，调用bind绑定端口，调用listen监听端口,监听之后，套接字从CLOSED状态变为LISTEN状态</p><p>2、收到客户端发来的SYN报文，回复SYN+ACK,这时在未完成连接队列中创建一个新项目,并设置为SYN_RECV状态，然后继续监听listenfd</p><p>3、再次收到对应的ACK报文,把连接未完成队列中的项目移入连接已完成队列，并设置为ESTABLISHED状态</p><p>4、服务器通过accept进行消费，从已完成队列中拿取连接</p><p>netstat命令的Recv-Q和Send-Q表示的就是socket buffer相关的内容</p><p>对于监听状态的套接字，Recv-Q表示的是未完成队列中的连接个数，Send-Q表示的是未完成连接队列的最大连接限制个数</p><p>对于已经建立的tcp连接，Recv-Q列表示的是recv buffer中还未被用户进程拷贝走的数据大小，</p><p>Send-Q表示的是远程主机还未返回ACK消息的数据大小</p><p><img src="image-20200919185139646.png" alt="image-20200919185139646"> </p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><p>ipv4地址由32位二进制表示，也可以每八位一组来表示。</p><p>IP地址范围为0.0.0.0-255.255.255.255</p><p>其中10.0.0.0～10.255.255.255、172.16.0.0～172.16.255.255、192.168.0.0～192.168.255.255为内网地址，在公网上不分配，127开头的为环回地址，代表本机。</p><p>主机号全为0的表示直接广播地址，主机号全为1的表示受限广播地址，区别为广播是否会被发给路由器。</p><h4 id="icmp"><a href="#icmp" class="headerlink" title="icmp"></a>icmp</h4><p>icmp报文包含在ip报文中，头部的type说明icmp报文的作用</p><p>常见的type有</p><p>0：echo reply ping 应答</p><p>8：echo request ping请求</p><h4 id="ipsec"><a href="#ipsec" class="headerlink" title="ipsec"></a>ipsec</h4>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
