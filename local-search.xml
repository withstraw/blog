<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL预编译</title>
    <link href="/2020/09/28/MySQL%E9%A2%84%E7%BC%96%E8%AF%91/"/>
    <url>/2020/09/28/MySQL%E9%A2%84%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL预编译"><a href="#MySQL预编译" class="headerlink" title="MySQL预编译"></a>MySQL预编译</h2><h3 id="0x01使用方法"><a href="#0x01使用方法" class="headerlink" title="0x01使用方法"></a>0x01使用方法</h3><pre><code class="hljs mysql">prepare f from &#39;select * from user where id &#x3D; ?&#39;;set @id&#x3D;1;execute f using @id;</code></pre><p><code>prepare 名称 from &#39;sql语句&#39;</code>（使用占位符替代参数）</p><p>sql语句可以是通过任意方式构造的字符串类型变量或值</p><pre><div class="caption"><span>PREPARE f;```删除预编译语句</span></div><code class="hljs DEALLOCATE">### 0x02 能预编译的语句&#96;&#96;&#96;mysqlALTER TABLEALTER USERANALYZE TABLECACHE INDEXCALLCHANGE MASTERCHECKSUM &#123;TABLE | TABLES&#125;COMMIT&#123;CREATE | DROP&#125; INDEX&#123;CREATE | RENAME | DROP&#125; DATABASE&#123;CREATE | DROP&#125; TABLE&#123;CREATE | RENAME | DROP&#125; USER&#123;CREATE | DROP&#125; VIEWDELETEDOFLUSH &#123;TABLE | TABLES | TABLES WITH READ LOCK | HOSTS | PRIVILEGES  | LOGS | STATUS | MASTER | SLAVE | USER_RESOURCES&#125;GRANTINSERTINSTALL PLUGINKILLLOAD INDEX INTO CACHEOPTIMIZE TABLERENAME TABLEREPAIR TABLEREPLACERESET &#123;MASTER | SLAVE&#125;REVOKESELECTSETSHOW &#123;WARNINGS | ERRORS&#125;SHOW BINLOG EVENTSSHOW CREATE &#123;PROCEDURE | FUNCTION | EVENT | TABLE | VIEW&#125;SHOW &#123;MASTER | BINARY&#125; LOGSSHOW &#123;MASTER | SLAVE&#125; STATUSSLAVE &#123;START | STOP&#125;TRUNCATE TABLEUNINSTALL PLUGINUPDATE</code></pre><h3 id="0x03防止sql注入的原理"><a href="#0x03防止sql注入的原理" class="headerlink" title="0x03防止sql注入的原理"></a>0x03防止sql注入的原理</h3><p>预编译一条sql语句，会将该sql语句编译后放到缓冲区中，待到execute执行语句时，将参数带入占位符再次进行解析，并执行。由于编译阶段已经识别了关键字，执行逻辑，输入的参数只能被作为字符串处理，无法做查询等操作了</p><h3 id="0x04-模拟预编译"><a href="#0x04-模拟预编译" class="headerlink" title="0x04 模拟预编译"></a>0x04 模拟预编译</h3><p>模拟预编译是为了防止某些版本的数据库不支持预编译，模拟预编译会在程序内部模拟数据库预处理的过程。也就是说，程序在内部模拟prepare,等到execute时，再将拼接后的完整sql语句发送给mysql数据库进行查询。</p><p>php模拟预编译本质上只是转义用户输入，相关函数是PDO::quote和mysqli_real_escape_string。</p><p>PDO可以通过PDO::ATTR_EMULATE_PREPARES参数控制是否开启模拟预编译，默认开启</p><h3 id="0x05预编译一定能防sql注入吗"><a href="#0x05预编译一定能防sql注入吗" class="headerlink" title="0x05预编译一定能防sql注入吗"></a>0x05预编译一定能防sql注入吗</h3><p>在prepare过程中的字符串拼接可能导致sql注入</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Requests库简单使用</title>
    <link href="/2020/09/21/Python-Requests%E5%BA%93%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/21/Python-Requests%E5%BA%93%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Python-Requests库简单使用"><a href="#Python-Requests库简单使用" class="headerlink" title="Python Requests库简单使用"></a>Python Requests库简单使用</h2><h3 id="0x1-requests-get"><a href="#0x1-requests-get" class="headerlink" title="0x1 requests.get"></a>0x1 requests.get</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsurl=<span class="hljs-string">&#x27;http://www.exmaple.com&#x27;</span>headers=&#123;    <span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;r=requests.get(url)<span class="hljs-comment">#自定义请求头</span>r=requests.get(url,headers=headers)r.status_code  <span class="hljs-comment">#状态吗</span>r.content   <span class="hljs-comment">#二进制字节码</span>r.text       <span class="hljs-comment">#文本格式响应</span></code></pre><h3 id="0x2-requests-post"><a href="#0x2-requests-post" class="headerlink" title="0x2 requests.post"></a>0x2 requests.post</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsdata=&#123;<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;cookies=&#123;<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;files=&#123;<span class="hljs-string">&quot;foo1&quot;</span>:<span class="hljs-string">&quot;filelikeobject&quot;</span><span class="hljs-string">&quot;foo2&quot;</span>:(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;/imge/png&quot;</span>)&#125;url=<span class="hljs-string">&quot;http://httpbin.org/post&quot;</span><span class="hljs-comment">#上传数据</span>r=requests.post(url,data=<span class="hljs-string">&quot;l am in body&quot;</span>)<span class="hljs-comment">#上传表单数据</span>r=requests.post(url,data=data)<span class="hljs-comment">#上传文件</span>r=requests.post(url,files=files)<span class="hljs-comment">#带有cookies</span>r=requests.post(url,cookies=cookies)r.text</code></pre><h3 id="0x3-session"><a href="#0x3-session" class="headerlink" title="0x3 session"></a>0x3 session</h3><pre><code class="hljs routeros">import requests<span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;http://httpbin.org&quot;</span><span class="hljs-attribute">s</span>=requests.session()s.<span class="hljs-builtin-name">get</span>(url)s.post(url)</code></pre><pre><code class="hljs qml"><span class="hljs-keyword">import</span> requests<span class="hljs-built_in">url</span>=<span class="hljs-string">&quot;http://httpbin.org&quot;</span><span class="hljs-keyword">with</span> requests.Session() <span class="hljs-keyword">as</span> <span class="hljs-attribute">s</span>:s.get(<span class="hljs-built_in">url</span>)s.post(<span class="hljs-built_in">url</span>)</code></pre><p>0x4 proxy</p><pre><code class="hljs makefile">import requestsurl=<span class="hljs-string">&quot;http://httpbin.org&quot;</span>proxies=&#123;<span class="hljs-string">&quot;http&quot;</span>:<span class="hljs-string">&quot;127.0.0.1:7777&quot;</span>,<span class="hljs-string">&quot;https&quot;</span>:<span class="hljs-string">&quot;127.0.0.1:777&quot;</span>&#125;r=requests.get(url,proxies=proxies)</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php 反序列化漏洞</title>
    <link href="/2020/08/22/php-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2020/08/22/php-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="php-反序列化漏洞"><a href="#php-反序列化漏洞" class="headerlink" title="php 反序列化漏洞"></a>php 反序列化漏洞</h2><h3 id="0x1整型的序列化"><a href="#0x1整型的序列化" class="headerlink" title="0x1整型的序列化"></a>0x1整型的序列化</h3><p><img src="image-20200921170331985.png" alt="image-20200921170331985"> </p><p>结果为<code>i:1;</code></p><p>i代表类型为整型，1为值</p><p>整型的序列化结果为<code>i:值;</code></p><h3 id="0x2字符串序列化"><a href="#0x2字符串序列化" class="headerlink" title="0x2字符串序列化"></a>0x2字符串序列化</h3><p><img src="image-20200921165623154.png" alt="image-20200921165623154"></p><p>结果为<code>s:6:&quot;string&quot;;</code> </p><p>s代表类型为字符串,6代表长度，string为值</p><p>字符串的序列化结果<code>s:长度:值;</code></p><h3 id="0x3-数组序列化"><a href="#0x3-数组序列化" class="headerlink" title="0x3 数组序列化"></a>0x3 数组序列化</h3><p><img src="image-20200921165824145.png" alt="image-20200921165824145"></p><p>结果为<code>a:1:&#123;s:3:&quot;foo&quot;;s:3:&quot;bar&quot;&#125;</code></p><p>a代表类型为数组，1代表数组长度，接着为值</p><p>s代表键的类型，3代表键的长度，接着为值</p><p>s代表值的类型，3代表值的长度，接着为值</p><p>数组的序列化结果<code>a:数组长度:&#123;键的序列化结果 值的序列化结果    键的序列化结果 值的序列化结果……&#125;</code></p><h3 id="0x4类的序列化结果"><a href="#0x4类的序列化结果" class="headerlink" title="0x4类的序列化结果"></a>0x4类的序列化结果</h3><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span></span>&#123;    <span class="hljs-keyword">const</span> constant=<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-keyword">public</span> $bar1=<span class="hljs-number">1</span>;<span class="hljs-keyword">protected</span> $bar2=<span class="hljs-string">&#x27;2&#x27;</span>;<span class="hljs-keyword">private</span> $bar3=[<span class="hljs-string">&#x27;3&#x27;</span>];&#125;$f=<span class="hljs-keyword">new</span> foo();$s=serialize($f);<span class="hljs-keyword">echo</span> str_replace(chr(<span class="hljs-number">0</span>),<span class="hljs-string">&#x27;%00&#x27;</span>,$s).PHP_EOL;<span class="hljs-comment">#为了便于观看，将不可见的0x00变为%00</span></code></pre><p>结果为</p><pre><code class="hljs php">O:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;foo&quot;</span>:<span class="hljs-number">3</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;bar1&quot;</span>;i:<span class="hljs-number">1</span>;s:<span class="hljs-number">7</span>:<span class="hljs-string">&quot;%00*%00bar2&quot;</span>;s:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;2&quot;</span>;s:<span class="hljs-number">9</span>:<span class="hljs-string">&quot;%00foo%00bar3&quot;</span>;a:<span class="hljs-number">1</span>:&#123;i:<span class="hljs-number">0</span>;s:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;3&quot;</span>;&#125;&#125;</code></pre><p>O代表类型为对象，3为类的名称长度，foo为类的名称</p><p>接下来依次是类的成员变量名称与值的序列化结果，可以看到他们的名称发生了变化，这种变化与关键字protected,public,private有关</p><p>成员变量bar1为public,他的名称没有变化</p><p>成员变量bar2为protected,他的名称变为了<code>%00*%00bar2</code>,bar2为原来的名称</p><p>成员变量bar3为private,他的名称变为了<code>%00foo%00bar3</code>，foo为类名，bar3为原来的名称</p><p>对象的序列化结果<code>O:类名长度:类名:&#123;成员变量键序列化结果 成员变量值序列化结果 ……&#125;</code></p><p>其中成员变量键序列化结果有所不同 </p><p><code>protected 类型:键长度:%00*%00键名;</code></p><p><code>private 类型:键长度:%00类名%00键名;</code></p><h3 id="0x5-与反序列化有关的魔术方法-wakeup-sleep"><a href="#0x5-与反序列化有关的魔术方法-wakeup-sleep" class="headerlink" title="0x5 与反序列化有关的魔术方法 __wakeup,__sleep"></a>0x5 与反序列化有关的魔术方法 <code>__wakeup,__sleep</code></h3><p><code>__sleep</code>在对象被序列化时调用，返回包含对象中所有应被序列化的变量名称的数组（按照规定）</p><p><code>__wakeup</code>在对象被反序列化时调用，通常进行初始化操作，如果序列化字符串的个数出错，则不会调用。可以用于绕过<code>__wakeup</code>函数中的检查。</p><h3 id="0x6-一些可以利用的魔术方法-toString-invoke-callable-get-set-call"><a href="#0x6-一些可以利用的魔术方法-toString-invoke-callable-get-set-call" class="headerlink" title="0x6 一些可以利用的魔术方法 __toString,__invoke,__callable,__get,__set,__call"></a>0x6 一些可以利用的魔术方法 <code>__toString,__invoke,__callable,__get,__set,__call</code></h3><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString"></a>__toString</h4><p>当一个类被当作字符串时，会调用该方法。此方法必须返回一个字符串。</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span></span>&#123;<span class="hljs-keyword">public</span> $bar1=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__toString</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;&#125;&#125;$f=<span class="hljs-keyword">new</span> foo();<span class="hljs-keyword">echo</span> $f.PHP_EOL;</code></pre><p><img src="image-20200921173027418.png" alt="image-20200921173027418"></p><h4 id="invoke"><a href="#invoke" class="headerlink" title="__invoke"></a>__invoke</h4><p>当尝试以调用一个函数的方式调用一个对象，会调用该方法</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span></span>&#123;<span class="hljs-keyword">public</span> $bar1=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params">$x</span>)</span>&#123;var_dump($x);&#125;&#125;$f=<span class="hljs-keyword">new</span> foo();$f(<span class="hljs-number">10</span>);var_dump(is_callable($f));</code></pre><p>输出</p><p><img src="image-20200921173333544.png" alt="image-20200921173333544"></p><h4 id="get"><a href="#get" class="headerlink" title="__get"></a>__get</h4><p>在访问不可访问属性赋值时，如不存在的属性，会被调用。</p><h4 id="set"><a href="#set" class="headerlink" title="__set"></a>__set</h4><p>在给不可访问属性赋值时，如不存在的属性，会被调用。</p><h4 id="call"><a href="#call" class="headerlink" title="__call"></a><code>__call</code></h4><p>在对象中调用一个不可访问方法时，如不存在的方法，<code>__call </code>会被调用。</p><h3 id="0x7可以使用的内置类"><a href="#0x7可以使用的内置类" class="headerlink" title="0x7可以使用的内置类"></a>0x7可以使用的内置类</h3><h3 id="toString"><a href="#toString" class="headerlink" title="__toString"></a><code>__toString</code></h3><h4 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h4><p>适用于php5、7版本</p><p>开启报错的情况下，能够进行XSS攻击</p><p><code>$a=new Exception(&quot;&lt;script&gt; alert(1)&lt;/script&gt;&quot;);</code></p><h4 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h4><p>适用于php7版本</p><p>开启报错的情况下，能够进行XSS攻击</p><p><code>$a=new Error(&quot;&lt;script&gt; alert(1)&lt;/script&gt;&quot;);</code></p><h4 id="call-1"><a href="#call-1" class="headerlink" title="__call"></a><code>__call</code></h4><h4 id="SoapClient类"><a href="#SoapClient类" class="headerlink" title="SoapClient类"></a>SoapClient类</h4><p>php5,php7均存在此类</p><p>可以用来SSRF攻击</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$a = <span class="hljs-keyword">new</span> SoapClient(<span class="hljs-literal">null</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;uri&#x27;</span>=&gt;<span class="hljs-string">&#x27;http://example.com:5555&#x27;</span>, <span class="hljs-string">&#x27;location&#x27;</span>=&gt;<span class="hljs-string">&#x27;http://example.com:5555/aaa&#x27;</span>));$b = serialize($a);<span class="hljs-keyword">echo</span> $b;$c = unserialize($b);$c-&gt;a();</code></pre><p>调用后会将返回结果写到自己的成员变量里</p><p>对于这个类，还存在一个漏洞，这个类允许设置user-agent头部，如果在设置user-agent值得时候写入<code>\r\n</code>，就可以写入任意头部</p><h3 id="0x8-phar的反序列化"><a href="#0x8-phar的反序列化" class="headerlink" title="0x8 phar的反序列化"></a>0x8 phar的反序列化</h3><p>当使用<code>phar://</code>伪协议作为路径打开文件的时候，会将该文件反序列化</p><p>phar文件由四部分组成</p><pre><code class="hljs txt">1、stub:phar文件标识2、a manifest describing the contents以序列化方式存储，用户自定义的meta-data，攻击所用到的地方3、the file contents文件内容4、[optional] a signature for verifying Phar integrity (phar file format only)签名，放在文件末尾</code></pre><p>创建phar文件</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;&#125;$phar=<span class="hljs-keyword">new</span> Phar(<span class="hljs-string">&quot;phar.phar&quot;</span>); <span class="hljs-comment">//在这一步时后缀必须为phar,但在利用时不需要</span>$phar-&gt;startBuffering();<span class="hljs-comment">//在文件开头设置stub,标准格式,可以添加其他文件的头</span>$phar-&gt;setStub(<span class="hljs-string">&quot;GIF89a&quot;</span>.<span class="hljs-string">&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;</span>); <span class="hljs-comment">//插入序列化的meta-data,攻击利用的关键</span>$o=<span class="hljs-keyword">new</span> Foo();$phar-&gt;setMetadata($o); <span class="hljs-comment">//将自定义的meta-data存入mainifest;</span>$phar-&gt;addFromString(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>); <span class="hljs-comment">//添加要压缩的文件</span><span class="hljs-comment">//签名自动计算</span>$phar-&gt;stopBuffering();<span class="hljs-meta">?&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Pickle反序列化</title>
    <link href="/2020/08/22/Python-Pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2020/08/22/Python-Pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="Python-Pickle反序列化"><a href="#Python-Pickle反序列化" class="headerlink" title="Python Pickle反序列化"></a>Python Pickle反序列化</h2><h3 id="0x01-Pickle介绍"><a href="#0x01-Pickle介绍" class="headerlink" title="0x01 Pickle介绍"></a>0x01 Pickle介绍</h3><p>Pickle模块是可以用来序列化和反序列化，可以被操作的对象有</p><pre><code class="hljs txt">None、True、False整数、浮点数、复数str、byte、bytearray只包含可操作对象的tuple、list、set、dict定义在模块最外层的函数（不包含lambda）定义在模块最外层的内置函数定义在模块最外层的类__dict__属性或__getstate__()函数的返回值能够被封存的类</code></pre><p><code>pickle.load</code>从文件读取序列化后的对象，<code>pickle.dump</code>序列化对象到文件</p><p><code>pickle.loads</code>从byte-like object读取序列化后的对象，<code>pickle.dumps</code>将序列化后的对象以bytes类型返回</p><h3 id="0x02-Pickle-原理"><a href="#0x02-Pickle-原理" class="headerlink" title="0x02 Pickle 原理"></a>0x02 Pickle 原理</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>pickle在序列化时只序列化类的名称<code>__class__</code>,和对象属性列表<code>__dict__</code></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span>(<span class="hljs-params">obj</span>):</span>    <span class="hljs-keyword">return</span> (obj.__class__, obj.__dict__)</code></pre><p>也就是说类属性不会被序列化</p><h4 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h4><p>pickle反序列化时并不会调用类的<code>__init__</code>方法,而是使用<code>__new__</code>方法创建实例,然后修改实例的<code>__dict__</code>属性</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span>(<span class="hljs-params">cls, attributes</span>):</span>    obj = cls.__new__(cls)    obj.__dict__.update(attributes)    <span class="hljs-keyword">return</span> obj</code></pre><p>从底层来讲</p><p>Pickle模块维护了两个栈:当前栈,和前序栈,还有一个存储区,这里不看.序列化得到的字节其实类似于由操作码和操作数的字节码.复原一个类的实际操作和上面的load()函数基本相同.我们可以使用pickletools来查看</p><pre><code class="hljs txt">pickletools是python自带的pickle调试器，有三个功能：反汇编一个已经被打包的字符串、优化一个已经被打包的字符串、返回一个迭代器来供程序使用。我们一般使用前两种。</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<span class="hljs-keyword">import</span> pickletools<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.q=<span class="hljs-string">&#x27;w&#x27;</span>        self.p=<span class="hljs-string">&#x27;z&#x27;</span>s=pickle.dumps(A())s=pickletools.optimize(s)print(s)pickletools.dis(s)</code></pre><pre><code class="hljs python">返回结果<span class="hljs-string">b&#x27;\x80\x04\x95!\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x8c\x01A\x93)\x81&#125;(\x8c\x01q\x8c\x01w\x8c\x01p\x8c\x01zub.&#x27;</span>    <span class="hljs-number">0</span>: \x80 PROTO      <span class="hljs-number">4</span>当前协议版本<span class="hljs-number">4</span>    <span class="hljs-number">2</span>: \x95 FRAME      <span class="hljs-number">33</span>接下来为新的栈帧   <span class="hljs-number">11</span>: \x8c SHORT_BINUNICODE <span class="hljs-string">&#x27;__main__&#x27;</span>  压栈__main__   <span class="hljs-number">21</span>: \x8c SHORT_BINUNICODE <span class="hljs-string">&#x27;A&#x27;</span>  压栈A   <span class="hljs-number">24</span>: \x93 STACK_GLOBAL 弹栈两次,压入__main__.A模块   <span class="hljs-number">25</span>: )    EMPTY_TUPLE 压栈空元组()   <span class="hljs-number">26</span>: \x81 NEWOBJ 弹栈两次,分别存入args,cls,执行cls.__new__(cls,())   <span class="hljs-number">27</span>: &#125;    EMPTY_DICT  压栈空字典   <span class="hljs-number">28</span>: (    MARK 将当前栈元素作为列表[A(),&#123;&#125;]压入前序栈,清空当前栈   <span class="hljs-number">29</span>: \x8c     SHORT_BINUNICODE <span class="hljs-string">&#x27;q&#x27;</span>   压栈q   <span class="hljs-number">32</span>: \x8c     SHORT_BINUNICODE <span class="hljs-string">&#x27;w&#x27;</span>   压栈w   <span class="hljs-number">35</span>: \x8c     SHORT_BINUNICODE <span class="hljs-string">&#x27;p&#x27;</span>   压栈p   <span class="hljs-number">38</span>: \x8c     SHORT_BINUNICODE <span class="hljs-string">&#x27;z&#x27;</span>   压栈z   <span class="hljs-number">41</span>: u        SETITEMS   (MARK at <span class="hljs-number">28</span>)    将当前栈的内容存入数组arr=[<span class="hljs-string">&#x27;q&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-string">&#x27;p&#x27;</span>,<span class="hljs-string">&#x27;z&#x27;</span>],然后把当前栈恢复为调用mark前,现在当前栈剩下A(),&#123;&#125;.弹栈(规定是字典),两个一组读取arr,存入弹出的字典   <span class="hljs-number">42</span>: b    BUILD 栈顶存进state,弹栈,栈顶存进inst,弹栈,用state来更新inst,得到的对象压栈   <span class="hljs-number">43</span>: .    STOP                          弹栈结束highest protocol among opcodes = <span class="hljs-number">4</span></code></pre><p>原讲解见<a href="https://zhuanlan.zhihu.com/p/89132768">https://zhuanlan.zhihu.com/p/89132768</a></p><p>pickletools源码中存有详细的操作码介绍</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>awk 用法</title>
    <link href="/2020/08/22/awk-%E7%94%A8%E6%B3%95/"/>
    <url>/2020/08/22/awk-%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="awk使用"><a href="#awk使用" class="headerlink" title="awk使用"></a>awk使用</h2><h3 id="0x1-格式"><a href="#0x1-格式" class="headerlink" title="0x1 格式"></a>0x1 格式</h3><p>awk 选项 ‘BEGIN{action} pattern1 &amp;&amp; pattern2 || pattern3{action1}pattern4{action2;action3}END{action}’ 文件</p><h3 id="0x2-执行流程"><a href="#0x2-执行流程" class="headerlink" title="0x2 执行流程"></a>0x2 执行流程</h3><p>awk首先执行BEGIN代码块</p><p>然后按照RS指定的分隔符从文件中读取文件，RS默认为\n,如果没有指定文件，则从标准输入读取</p><p>每读取一条记录</p><p>都将设置NR,FNR,RT,$0等变量</p><p>（默认）按照FS指定的分隔符分割字段，赋值给$1,$2,$3……$(NF-1),$NF,NF表示字段的个数</p><p>对main代码块的pattern进行匹配，匹配则执行action</p><p>执行END代码块</p><h3 id="0x3分割字段的方法"><a href="#0x3分割字段的方法" class="headerlink" title="0x3分割字段的方法"></a>0x3分割字段的方法</h3><p>在BEGIN中指定对每条记录都有效，</p><p><img src="image-20200921150511908.png" alt="image-20200921150511908"></p><p>在main代码块则只对第二条及以后有效。在对第n行的action中指定，只对对接下来的行有效。</p><p><img src="image-20200921150745821.png" alt="image-20200921150745821"></p><p>可以通过PROCINFO[“FS”]查看</p><p><img src="image-20200921152241706.png" alt="image-20200921152241706"></p><h4 id="FS（默认）"><a href="#FS（默认）" class="headerlink" title="FS（默认）"></a>FS（默认）</h4><p>指定分隔符，默认为空格，默认情况下识别连续空格和其他空白符whitespace</p><p><img src="image-20200921151241855.png" alt="image-20200921151241855"></p><p><img src="image-20200921150949617.png" alt="image-20200921150949617"></p><p>FIELDWIDTHS</p><p>按字符格式分割字段 1 1:1代表第一个字段长度为1,跳过一个字符读取一个字符作为第二个字段，剩下的丢弃，字符读完为止</p><p><img src="image-20200921151549478.png" alt="image-20200921151549478"></p><p><img src="image-20200921151629782.png" alt="image-20200921151629782"></p><h4 id="FPAT"><a href="#FPAT" class="headerlink" title="FPAT"></a>FPAT</h4><p>按照正则表达式匹配字段</p><p><img src="image-20200921151823401.png" alt="image-20200921151823401"></p><h3 id="0x4-一些自带属性"><a href="#0x4-一些自带属性" class="headerlink" title="0x4 一些自带属性"></a>0x4 一些自带属性</h3><p>RS 记录分割     RT    输出时用RT记录进行连接</p><p>FS 字段分割    FT    输出时用FT字段进行连接，<code>，代表FT</code></p><p>FNR   单个输入的行号   NR  所有输入的行号</p><p>NF   字段数</p><p><img src="image-20200921152859320.png" alt="image-20200921152932083"></p><p>0x5 特殊的空值</p><p>awk代码块中未被赋值的参数，会根据它进行的操作是算数运算还是其他运算进行初始化。</p><p><img src="image-20200921153856329.png" alt="image-20200921153856329"></p><p>在处理第一行时，由于a为初始化，a可以为空字符串，0，false,由于前面进行了取反的布尔运算，所以a取false</p><p>取反后为True赋值给a,所以第一行pattern为真。</p>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>owasp top 10</title>
    <link href="/2020/08/21/owasp-top-10/"/>
    <url>/2020/08/21/owasp-top-10/</url>
    
    <content type="html"><![CDATA[<h2 id="owasp-top10漏洞"><a href="#owasp-top10漏洞" class="headerlink" title="owasp top10漏洞"></a>owasp top10漏洞</h2><h3 id="0x1-注入（Injection）"><a href="#0x1-注入（Injection）" class="headerlink" title="0x1 注入（Injection）"></a>0x1 注入（Injection）</h3><p>注入漏洞，例如SQL,NOSQL,OS和LDAP注入，当不可信的数据被当作命令或者查询的一部分解析时出现。攻击者的恶意数据能够让解释器执行意料之外的命令或者绕过授权读取数据。</p><h3 id="0x2-错误的身份验证-Broken-Authentication"><a href="#0x2-错误的身份验证-Broken-Authentication" class="headerlink" title="0x2 错误的身份验证(Broken Authentication)"></a>0x2 错误的身份验证(Broken Authentication)</h3><p>应用的有关身份验证和session管理的实现往往是错误的，这使得攻击者能拿到密码，keys,session tokens，或者让攻击者挖掘其他的漏洞，暂时或永久的冒充其他用户。</p><h3 id="0x3-敏感信息泄露（Sensitive-Data-Exposure）"><a href="#0x3-敏感信息泄露（Sensitive-Data-Exposure）" class="headerlink" title="0x3 敏感信息泄露（Sensitive Data Exposure）"></a>0x3 敏感信息泄露（Sensitive Data Exposure）</h3><p>许多web应用和api没有正确的保护敏感数据，攻击者可能窃取或者修改这些未被保护好的数据，进行信用卡诈骗，身份窃取，或者其他的犯罪行为。敏感数据如果没有进行保护，例如静态、动态加密，在浏览器间传输时实行特别的预防措施，就很可能会泄露。</p><h3 id="0x4-XXE（XML-External-Entities）"><a href="#0x4-XXE（XML-External-Entities）" class="headerlink" title="0x4 XXE（XML External Entities）"></a>0x4 XXE（XML External Entities）</h3><p>许多旧的、配置错误的XML处理器在xml文档里进行外部实体引用。外部实体能够被用来读取服务器内部的文件，通过file协议，还可以进行服务器端口扫描、远程代码执行、拒绝服务攻击。</p><h3 id="0x5-错误的访问控制（Broken-Access-Control）"><a href="#0x5-错误的访问控制（Broken-Access-Control）" class="headerlink" title="0x5 错误的访问控制（Broken Access Control）"></a>0x5 错误的访问控制（Broken Access Control）</h3><p>被授权用户的行为往往没有被正确的限制。攻击者可以利用这些漏洞访问未授权的功能，或者读取不属于他的数据，例如访问其他用户的帐号，访问敏感文件，修改其他用户的数据，更改访问权限等</p><h3 id="0x6-错误的安全配置（Security-Misconfiguration）"><a href="#0x6-错误的安全配置（Security-Misconfiguration）" class="headerlink" title="0x6 错误的安全配置（Security Misconfiguration）"></a>0x6 错误的安全配置（Security Misconfiguration）</h3><p>错误的安全配置是最常见的问题。往往是由于使用了默认的不安全的配置。厂商不仅需要根据不同操作系统、框架、库和应用来进行安全配置，而且这些配置要按时更新，打补丁。</p><h3 id="0x7跨站脚本攻击（Cross-Site-Scripting-Xss）"><a href="#0x7跨站脚本攻击（Cross-Site-Scripting-Xss）" class="headerlink" title="0x7跨站脚本攻击（Cross-Site Scripting Xss）"></a>0x7跨站脚本攻击（Cross-Site Scripting Xss）</h3><p>XSS漏洞的存在</p><p>1、在新的web页面包含不可信的数据，没有进行正确的验证和转义</p><p>2、通过可以创建HTML或者JS的浏览器API，用用户提交的数据更新web页面</p><p>XSS让攻击者能够在victim的浏览器上执行代码，XSS能够劫持用户的session,污染网站，或者将用户重定向到恶意网站（可以和CSRF漏洞配合）</p><h3 id="0x8不安全的反序列化（Insecure-Deserialization）"><a href="#0x8不安全的反序列化（Insecure-Deserialization）" class="headerlink" title="0x8不安全的反序列化（Insecure Deserialization）"></a>0x8不安全的反序列化（Insecure Deserialization）</h3><p>不安全的反序列化往往导致了远程代码执行。即使反序列化漏洞没有导致远程代码执行，也能够被用来辅助攻击，包括重放攻击，注入攻击，越权攻击</p><h3 id="0x9使用有公开漏洞的组件（Using-Components-with-Known-Vulnerablilities）"><a href="#0x9使用有公开漏洞的组件（Using-Components-with-Known-Vulnerablilities）" class="headerlink" title="0x9使用有公开漏洞的组件（Using Components with Known Vulnerablilities）"></a>0x9使用有公开漏洞的组件（Using Components with Known Vulnerablilities）</h3><p>组件，例如函数库，框架和其他的软件模块，他们都和web应用有一样的权限。如果使用了一个vulnerable的组件，对他的攻击会帮助攻击者，造成严重的数据丢失或者攻击者接管服务器。使用有已知安全漏洞的组件会破坏已有的安全防线，导致各种攻击。</p><h3 id="0x10-无效的日志或监视（Insufficient-Logging-amp-Monitoring）"><a href="#0x10-无效的日志或监视（Insufficient-Logging-amp-Monitoring）" class="headerlink" title="0x10 无效的日志或监视（Insufficient Logging &amp; Monitoring）"></a>0x10 无效的日志或监视（Insufficient Logging &amp; Monitoring）</h3><p>无效的日志或者监视，加上没有应急响应（或者是低效的），使攻击者能够持续攻击系统，维持权限，然后转向更多的系统。攻击者能够篡改，收集，毁坏victim的数据。大多数的研究表明检测到数据泄露（data breach）的时间超过200天。</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcp/ip网络模型</title>
    <link href="/2020/08/19/tcp-ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <url>/2020/08/19/tcp-ip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="tcp-ip-网络模型"><a href="#tcp-ip-网络模型" class="headerlink" title="tcp/ip 网络模型"></a>tcp/ip 网络模型</h2><p>分为五层，从上到下为应用层、传输层、网络层、数据链路层、物理层。</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h4 id="http（超文本传输协议）"><a href="#http（超文本传输协议）" class="headerlink" title="http（超文本传输协议）"></a>http（超文本传输协议）</h4><p>可以通过<code>curl url -v</code>查看一次完整的http请求过程</p><p><img src="image-20200919173124218.png" alt="image-20200919173124218"> </p><p>以上的流程可以总结为：</p><p>1、和服务器的端口建立tcp链接（默认为80端口）</p><p>2、发送http请求，包含请求头和请求体，请求头包含多个键值对<code>key1:value1</code>每行以<code>\r\n</code>分割，当遇到两个<code>\r\n</code>表示请求头的结束，接下来全是请求体</p><p>3、服务器返回响应，包含响应头和响应体，格式与http请求基本相同</p><p>4、和服务器断开tcp链接</p><h4 id="dns（域名系统）"><a href="#dns（域名系统）" class="headerlink" title="dns（域名系统）"></a>dns（域名系统）</h4><p>由于32位二进制的ip地址十分难记，我们使用域名来方便记忆。但是计算机不认识域名，前辈们就开发了dns域名系统，实现域名和ip的转换。</p><p>由于计算机无法理解dns系统之间的交流方式，所以通常通过一个resolver来和域名系统交流。我们将dns请求发给resolver,resolver来和dns交流，并返回给我们一个ip。查询域名为 <a href="http://www.example.com/">www.example.com</a> 的ip，完整的交流过程为：</p><p>1、计算机将dns请求发给resolver</p><p>2、resolver询问根服务器，根服务器不知道，但是.com服务器知道。</p><p>3、于是resolver询问com服务器，com服务器表示exmaple.com知道</p><p>4、询问example.com,得到ip地址</p><p>当然，由于缓存的存在，通常我们不需要走完全程，例如resolver缓存了dns查询记录，我们直接就可以拿到结果。再比如我们缓存了com服务器知道结果，则直接询问com服务器。</p><h4 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h4><p>使用公私钥加密方式，提供安全的隧道。</p><h3 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h3><h4 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h4><p>tcp报文记录了源端口和目的端口</p><p>端口一共有65535个，前1024个为公认端口，他们紧密绑定了一些服务。只有root有权限控制。</p><p>发送http请求时，源端口为系统任意选择大于1024的任意端口，目的端口默认为80</p><p>握手过程分为三步</p><p>1、客户端发送<code>SYN=x</code>，请求建立连接，客户端状态为syn-send</p><p>2、服务器收到，发送<code>SYN=y,ACK=x+1</code>,服务器状态为syn-received</p><p>3、客户端收到请求，发送<code>ACK=y+1</code>,连接建立</p><p>对于tcp的实现socket来说</p><p>服务端</p><p>1、使用socket创建监听套接字listenfd，调用bind绑定端口，调用listen监听端口,监听之后，套接字从CLOSED状态变为LISTEN状态</p><p>2、收到客户端发来的SYN报文，回复SYN+ACK,这时在未完成连接队列中创建一个新项目,并设置为SYN_RECV状态，然后继续监听listenfd</p><p>3、再次收到对应的ACK报文,把连接未完成队列中的项目移入连接已完成队列，并设置为ESTABLISHED状态</p><p>4、服务器通过accept进行消费，从已完成队列中拿取连接</p><p>netstat命令的Recv-Q和Send-Q表示的就是socket buffer相关的内容</p><p>对于监听状态的套接字，Recv-Q表示的是未完成队列中的连接个数，Send-Q表示的是未完成连接队列的最大连接限制个数</p><p>对于已经建立的tcp连接，Recv-Q列表示的是recv buffer中还未被用户进程拷贝走的数据大小，</p><p>Send-Q表示的是远程主机还未返回ACK消息的数据大小</p><p><img src="image-20200919185139646.png" alt="image-20200919185139646"> </p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><p>ipv4地址由32位二进制表示，也可以每八位一组来表示。</p><p>IP地址范围为0.0.0.0-255.255.255.255</p><p>其中10.0.0.0～10.255.255.255、172.16.0.0～172.16.255.255、192.168.0.0～192.168.255.255为内网地址，在公网上不分配，127开头的为环回地址，代表本机。</p><p>主机号全为0的表示直接广播地址，主机号全为1的表示受限广播地址，区别为广播是否会被发给路由器。</p><h4 id="icmp"><a href="#icmp" class="headerlink" title="icmp"></a>icmp</h4><p>icmp报文包含在ip报文中，头部的type说明icmp报文的作用</p><p>常见的type有</p><p>0：echo reply ping 应答</p><p>8：echo request ping请求</p><h4 id="ipsec"><a href="#ipsec" class="headerlink" title="ipsec"></a>ipsec</h4>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SESSION_UPLOAD_PROGRESS利用</title>
    <link href="/2019/09/22/SESSION-UPLOAD-PROGRESS%E5%88%A9%E7%94%A8/"/>
    <url>/2019/09/22/SESSION-UPLOAD-PROGRESS%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="SESSION-UPLOAD-PROGRESS利用"><a href="#SESSION-UPLOAD-PROGRESS利用" class="headerlink" title="SESSION_UPLOAD_PROGRESS利用"></a>SESSION_UPLOAD_PROGRESS利用</h1><h3 id="0x01-前提"><a href="#0x01-前提" class="headerlink" title="0x01 前提"></a>0x01 前提</h3><p><img src="image-20200922163534450.png" alt="image-20200922163534450"></p><pre><code class="hljs php">session.upload_progress.enabled=Onsession.serialize_handler在php_serialize和其他两种之间进行过切换PS:serialize_handler存在三种    php:键名|经过serialize()函数序列化的值    php_serialize(php&gt;<span class="hljs-number">5.5</span><span class="hljs-number">.4</span>):serialize()函数序列化的值    php_binary:键名的长度对应的ascii字符+键名+经过serialize()函数序列化的值</code></pre><h3 id="0x02-session-upload-progress介绍"><a href="#0x02-session-upload-progress介绍" class="headerlink" title="0x02 session upload progress介绍"></a>0x02 session upload progress介绍</h3><p>当<code>session.upload_progress.enable=On</code>时,php能在上传文件时检测上传进度.</p><p>当上传文件在处理中时,同时POST一个与<code>session.upload_progress.name=SESSION_UPLOAD_PROGRESS</code>同名的变量时,会将上传进度信息写入Session,他会在$_SESSION中添加一组数据,索引是<code>session.upload_progress.prefix和session.upload_progress.name连接在一起的值</code></p><p>我们还知道,php的Session信息会被写入sess_$PHPSESSID文件中,这代表着我们能向服务器的session.save_path路径下写入文件</p><h3 id="0x03-脚本"><a href="#0x03-脚本" class="headerlink" title="0x03 脚本"></a>0x03 脚本</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsurl=<span class="hljs-string">&quot;&quot;</span>payload=<span class="hljs-string">&quot;123&quot;</span>files=&#123;<span class="hljs-string">&quot;file&quot;</span>:(<span class="hljs-string">&quot;filename&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;image/png&quot;</span>)&#125;data=&#123;    <span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span>:payload&#125;s=requests.session()resp=s.post(url,data=data,files=files)</code></pre><h3 id="0x04达成效果"><a href="#0x04达成效果" class="headerlink" title="0x04达成效果"></a>0x04达成效果</h3><p>在<code>session.save_path</code>路径下上传了文件名为<code>sess_$PHPSESSID</code>的文件,可以向该文件写入任何内容,并且在php读取session文件时,会反序列化该文件.</p><pre><code class="hljs pgsql">注:在<span class="hljs-keyword">session</span>.serialize_handler不为php_serialize时,<span class="hljs-string">&#x27;|&#x27;</span>是被禁止写入的.反序列化漏洞利用的关键就是使用<span class="hljs-string">&#x27;|&#x27;</span>分割字段</code></pre><h3 id="0x05-注意"><a href="#0x05-注意" class="headerlink" title="0x05 注意"></a>0x05 注意</h3><p><code>session.upload_progress.cleanup</code>开启时,会在文件上传完毕后删除对应的session文件.利用时可以使用大文件和条件竞争.在session文件未被删除前利用.</p>]]></content>
    
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
